{"0": {
    "doc": "yame chunk",
    "title": "yame chunk",
    "content": "Usage: yame chunk [options] &lt;in.cx&gt; &lt;outdir&gt; Options: -v verbose -s chunk size -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_chunk.html",
    
    "relUrl": "/docs/subcommands/YAME_chunk.html"
  },"1": {
    "doc": "yame chunkchar",
    "title": "yame chunkchar",
    "content": "Usage: yame chunkchar [options] &lt;in.txt&gt; Options: -v verbose -s chunk size -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_chunkchar.html",
    
    "relUrl": "/docs/subcommands/YAME_chunkchar.html"
  },"2": {
    "doc": "yame dsample",
    "title": "yame dsample",
    "content": "Usage: yame dsample [options] &lt;in.cx&gt; &lt;out.cx&gt; Options: -s [N] seed for sampling. -N [N] number of records to sample. (default: 100). When higher than available, capped to available. -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_dsample.html",
    
    "relUrl": "/docs/subcommands/YAME_dsample.html"
  },"3": {
    "doc": "yame index",
    "title": "yame index",
    "content": "Usage: yame index [options] &lt;in.cx&gt; The index file name default to &lt;in.cx&gt;.idx Options: -s [file path] tab-delimited sample name list (use first column) -1 [sample name] add one sample to the end of the index -c output index to console -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_index.html",
    
    "relUrl": "/docs/subcommands/YAME_index.html"
  },"4": {
    "doc": "yame info",
    "title": "yame info",
    "content": "Usage: yame info [options] &lt;in.cx&gt; Options: -1 Report one record per file. -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_info.html",
    
    "relUrl": "/docs/subcommands/YAME_info.html"
  },"5": {
    "doc": "yame mask",
    "title": "yame mask",
    "content": "Usage: yame mask [options] &lt;in.cg&gt; &lt;mask.cx&gt; Options: -v verbose -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_mask.html",
    
    "relUrl": "/docs/subcommands/YAME_mask.html"
  },"6": {
    "doc": "yame pack",
    "title": "yame pack",
    "content": "Usage: yame pack [options] &lt;in.txt&gt; &lt;out.cx&gt; The input text file must match the dimension and order of the reference CpG bed file. Options: -f [char] Format specification (choose one character or number): (b) Binary data. Format default to 0 or 1 depending on size: 0 - 1 byte for 8 binary CpGs 1 - Value (1 byte) + Run-Length Encoding (RLE) (2 bytes) (s) State data. Format default to 2: 2 - State text + Index RLE (Best for chromatin states). Use format 0 for sequence context. (m) Sequencing MU data. Format default to 3: 3 - MU RLE + Ladder byte (Input: 2-column text, M and U). (d) Differential meth data. Format default to 6: 5 - 2-bits + NA-RLE (Input: only 0, 1, 2 values). 6 - 2-bits boolean for S (set) and U (universe). (Input: 2-column text, S and U). (n) Fraction data. Format default to 4: 4 - Fraction / NA-RLE (32 bytes). (r) Reference coordinates. Format default to 7: 7 - Compressed BED format for CGs. -u [int] Number of bytes per unit data when inflated (1-8). Lower values are more memory efficient but may be lossier. 0 - Inferred from data. -v Verbose mode -h Display this help message . ",
    "url": "/YAME/docs/subcommands/YAME_pack.html",
    
    "relUrl": "/docs/subcommands/YAME_pack.html"
  },"7": {
    "doc": "yame pairwise",
    "title": "yame pairwise",
    "content": "Usage: yame pairwise [options] &lt;MU1.cx&gt; (&lt;MU2.cx&gt;) Return a format 6 set that represent differential methylation between MU1 and MU2. If MU2 is not given, use the top 2 samples in MU1.cx. Options: -o output cx file name. if missing, output to stdout without index. -H 1: higher meth level in sample 1 than 2 (default). 2: higher meth level in sample 2 than 1. others: diff levels, i.e., 1 and 2 combined. -c minimum coverage (default: 1) -d minimum delta meth level/effect size (default: 0) -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_pairwise.html",
    
    "relUrl": "/docs/subcommands/YAME_pairwise.html"
  },"8": {
    "doc": "yame rowop",
    "title": "yame rowop",
    "content": "Usage: yame rowop [options] &lt;in.cx&gt; &lt;out&gt; Options: -o Operations (choose one): binasum Sum binary data to M and U (format 3). Output: new cx file. musum Sum M and U separately (format 3). Output: new cx file. mean Mean beta and counts of data points (format 3). Output: plain text (two columns). std Standard deviation. Requires format 3 cx. Output: plain text (std, counts). binstring Binarize data to row-wise string (format 3). Output: plain text file with binary strings. cometh Co-methylation of neighboring CGs. Output: plain text in uint64_t U0U1-U0M1-M0U1-M0M1, U0U2-U0M2-M0U2-M0M2, etc. '0' is target CG, followed by 1, 2, etc for neighboring CGs. Each pair occupies 16 bits. For visual, use -v. Intermediate methylations (0.3-0.7) are excluded. -w Number of neighboring CGs for cometh (default: 5). -c Minimum sequencing depth for rowops (default 1). -v Verbose mode -h Display this help message . ",
    "url": "/YAME/docs/subcommands/YAME_rowop.html",
    
    "relUrl": "/docs/subcommands/YAME_rowop.html"
  },"9": {
    "doc": "yame rowsub",
    "title": "yame rowsub",
    "content": "Usage: yame rowsub [options] &lt;in.cx&gt; This function outputs to stdout. The 0 in [beg0] below means 0-based. Similarly, [beg1], [end1], [index1], etc. The number in (), e.g., [blockIndex0]_(blockSize), is optional with a default. Options: -v verbose -l [PATH] rows in a plain text of [index1] on each row. index1: 1-based. No sorting requirement. -L [PATH] rows in a plain text of [chrm]_[beg1] on each row. Requires -R. No sorting requirement. -R [PATH] row coordinates to use. Required by -L. -1 The row coordinate (from -R) will be added to output as the first dataset. -m [PATH] rows in a mask file (format 1 or 2). -B [STR] a row index range [rowIndexBeg0]_(rowIndexEnd1). By default, rowIndexEnd1=rowIndexBeg0+1. -I [STR] a row index range [blockIndex0]_(blockSize). By default, blockSize=1000000. -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_rowsub.html",
    
    "relUrl": "/docs/subcommands/YAME_rowsub.html"
  },"10": {
    "doc": "yame split",
    "title": "yame split",
    "content": "Usage: yame split [options] &lt;in.cx&gt; out_prefix Options: -v verbose -s sample name list -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_split.html",
    
    "relUrl": "/docs/subcommands/YAME_split.html"
  },"11": {
    "doc": "yame subset",
    "title": "yame subset",
    "content": "Usage: yame subset [options] &lt;in.cx&gt; [&lt;sample1&gt; &lt;sample2&gt; ...] If -o &lt;out.cx&gt;, an index will also be generated. Otherwise, output .cx to stdout without index. Options: -v verbose -o output cx file name. if missing, output to stdout without index. -l Path to the sample list. Ignored if sample names are provided on the command line. -s Filter format 2 &lt;in.cx&gt; instead of samples in files. Output format 0. -H [N] Process N samples from the start of the list, where N is less than or equal to the total number of samples. -T [N] Process N samples from the end of the list, where N is less than or equal to the total number of samples. Requires index. -h This help . ",
    "url": "/YAME/docs/subcommands/YAME_subset.html",
    
    "relUrl": "/docs/subcommands/YAME_subset.html"
  },"12": {
    "doc": "yame summary",
    "title": "yame summary",
    "content": "Usage: yame summary [options] &lt;query.cm&gt; Query should be of format 0,1,2,3, can be a multi-sample set. Options: -m Mask feature (.cx) file, can be multi-sample. If '-', the whole sample will bed kept in memory, same as -M. -M All masks will be loaded to memory. This save disk IO. -u Optional universe set as a .cx file. If given, the masks and queries are both subset. -H Suppress header printing. -q The backup query file name if the query file name is '-'. -F Use full feature/query file name instead of base name. -T State features always show section names. -s Sample list provided to override the query index file. Only applies to the first query. -h This help. ",
    "url": "/YAME/docs/subcommands/YAME_summary.html",
    
    "relUrl": "/docs/subcommands/YAME_summary.html"
  },"13": {
    "doc": "yame unpack",
    "title": "yame unpack",
    "content": "Usage: yame unpack [options] &lt;in.cx&gt; [[sample 1], [sample 2], ...] Options: -a Process all samples -C Output column names -R [PATH] Row coordinate .cr file name. -r 0: Row coordinate output in chrm-beg0-end1 (default, for cg). 1: Row coordinate output in chrm-beg0-end0 (for allc). other: Row coordinate output in chrm_beg1. -l [PATH] Path to the sample list. Ignored if sample names are provided on the command line. -H [N] Process N samples from the start of the list, where N is less than or equal to the total number of samples. -T [N] Process N samples from the end of the list, where N is less than or equal to the total number of samples. Requires index. -f [N] Display format for data format 3. Options are: N == 0: Compound MU N &lt; 0: M&lt;tab&gt;U N &gt; 0: Fraction (with number for the min coverage) -c Enable chunk process -s Chunk size (default is 1M) -u [int] number of bytes for each unit data while inflated. Lower number needs less memory efficient but could be lossier. Can only be 1-8. 0 means this will be inferred from data. -h Display this help message. ",
    "url": "/YAME/docs/subcommands/YAME_unpack.html",
    
    "relUrl": "/docs/subcommands/YAME_unpack.html"
  },"14": {
    "doc": "7. Mask Data",
    "title": "7. Downsampling &amp; Masking Methylation Sites",
    "content": "YAME provides tools to control sparsity and apply masks to methylation data: . | yame dsample — randomly downsample sites to simulate lower coverage or sparsity. | yame mask — apply a binary mask to zero out sites or convert a binary format into a contextualized format 6. | . These functions are especially useful for benchmarking methods at different sparsity levels, building controlled simulation datasets, or restricting analyses to a specific universe of CpGs. ",
    "url": "/YAME/docs/dsample.html#7-downsampling--masking-methylation-sites",
    
    "relUrl": "/docs/dsample.html#7-downsampling--masking-methylation-sites"
  },"15": {
    "doc": "7. Mask Data",
    "title": "7.1 Random Downsampling with yame dsample",
    "content": "yame dsample randomly keeps a fixed number of non-NA sites per sample and masks out the rest. Supported input formats: . | Format 3 (M/U counts) | Format 6 (binary with universe bit; often used for single-cell sparse data) | . Basic usage: . yame dsample -N 10000 -s 1 input.cg &gt; downsampled.cg . This keeps 10,000 covered sites per sample (or all if fewer are available), using seed 1 for reproducibility. 7.1.1 What dsample Does (Format 3 vs Format 6) . | Format 3 (.cg, M/U counts) . | Eligible sites are those with M+U &gt; 0. | dsample randomly selects N such sites. | Selected sites keep their original M and U. | Non-selected sites are masked by setting M=U=0 (treated as missing/NA). | . | Format 6 (universe-bit binary) . | Eligible sites are those in the universe (FMT6_IN_UNI). | dsample randomly selects N universe positions. | Selected sites remain unchanged. | Non-selected sites have their universe bit cleared (FMT6_SET_NA), effectively dropping them from the analyzable universe. | . | . In both cases, if N is larger than the number of eligible sites, all eligible sites are kept (no error). 7.1.2 Key Options . yame dsample [options] &lt;in.cx&gt; [out.cx] . Options: . | -N [int] — number of eligible sites to keep per sample (default: 100). | -s [int] — random seed (default: current time). Use a fixed seed for reproducible downsampling. | -r [int] — number of independent replicates per sample (default: 1). | Each replicate is downsampled separately from the same input sample. | . | -h — show help. | . Output destination: . | If out.cx (positional) or -o is provided: write to that file and also write an index. | If no output is given: write to stdout (no index). | . 7.1.3 Replicates and Index Naming . When -r is greater than 1, dsample creates multiple downsampled versions of each input sample. | If the input .cx has an index: . | The original sample names are used as a base. | Replicates are suffixed: SampleA-0, SampleA-1, …, SampleA-(r-1). | . | If no input index exists: . | Samples are named 0, 1, 2, … internally. | Replicates follow the same base-rep naming pattern. | . | . Example: create 5 replicates with 50k sites each: . yame dsample -N 50000 -r 5 input.cg downsampled.cg . The resulting index in downsampled.cg.idx will contain entries like: . Sample1-0 Sample1-1 ... Sample1-4 Sample2-0 ... 7.1.4 Typical Use Cases . | Benchmarking methods at different sparsity levels Run the same pipeline on N = 1e5, N = 5e4, N = 1e4 to see robustness to coverage. | Generating multiple randomized sparsity replicates For each sample, simulate multiple downsampling replicates with different seeds or with -r. | Single-cell simulations with format 6 Use dsample to progressively restrict the universe of accessible CpGs and observe performance changes. | . For more help with dsample, run: . yame dsample -h . or see the dsample help page. ",
    "url": "/YAME/docs/dsample.html#71-random-downsampling-with-yame-dsample",
    
    "relUrl": "/docs/dsample.html#71-random-downsampling-with-yame-dsample"
  },"16": {
    "doc": "7. Mask Data",
    "title": "7.2 Masking and Contextualization with yame mask",
    "content": "yame mask applies a row-wise mask to a .cx file and optionally converts binary data into format 6 for contextualized single-cell usage. Basic usage: . yame mask input.cg mask.cx -o masked.cg . Here: . | input.cg — query methylation file (format 0, 1, or 3). | mask.cx — mask file (format 0, 1, or 3; internally converted to a binary format 0). | Output masked.cg contains only the unmasked positions. | . 7.2.1 Supported Inputs and Mask Semantics . | Mask file (mask.cx): . | Can be format 0, 1, or 3. | Format 1 and 3 masks are converted to format 0: . | For format 1: 1 is treated as masked, 0 unmasked. | For format 3: sites with M+U &gt; 0 become 1 (masked), zeros become 0. | . | . | Query file (input.cg): . | Format 3: M/U counts. | Format 0/1: binary. | . | . The mask must have the same row length as the query; otherwise the command will abort with an error. By default, bits that are 1 in the mask are masked out (removed). If you set -v, the mask is inverted, so bits that are 0 in the original mask become masked. 7.2.2 Operations Without Contextualization (default) . yame mask input.cg mask.cx -o masked.cg . | If the query is format 3: . | For every site where the mask bit is 1, set M=U=0. | Effect: those sites are treated as missing. | . | If the query is format 0: . | Perform a binary AND with the complement of the mask (c &amp;= ~mask). | Effect: all 1s in the mask are forced to 0 in the query. | . | . This is handy for: . | Removing blacklist CpGs from an existing .cg. | Removing low-quality or low-coverage sites. | Restricting analysis to a curated panel of CpGs. | . 7.2.3 Contextualizing to Format 6 (-c) . With -c, yame mask turns a binary query plus a mask into a format 6 object: . yame mask -c input_binary.cx mask.cx -o contextualized.cx . Behavior: . | The mask defines the universe (sites that exist in the cell). | The binary values in the query define whether each universe site is methylated (1) or unmethylated (0): . | If mask[i] = 1: . | If input[i] = 1 ➜ set format 6 as methylated (FMT6_SET1). | If input[i] = 0 ➜ set format 6 as unmethylated (FMT6_SET0). | . | If mask[i] = 0: . | Site is outside the universe (no entry in the resulting format 6 vector). | . | . | . With -v, the universe is effectively the complement of the mask (invert mask before contextualizing). This is useful for: . | Defining cell- or experiment-specific universes while retaining 0/1 methylation calls. | Converting feature masks into sparse, contextualized single-cell objects. | . 7.2.4 Command Summary . yame mask [options] &lt;in.cx&gt; &lt;mask.cx&gt; . Options: . | -o [PATH] — output .cx file name. If missing, write to stdout (no index). | -c — contextualize to format 6 using 1s in mask as the universe. | -v — invert the mask (mask 0s instead of 1s). | -h — help. | . Example workflows: . Mask out low-quality sites: . yame mask highcov.cg lowqual_mask.cx -o highcov_masked.cg . Restrict to a predefined universe and create fmt6: . yame mask -c raw_binary.cx universe_mask.cx -o cell_fmt6.cx . For more help with mask, run: . yame mask -h . or see the mask help page. ",
    "url": "/YAME/docs/dsample.html#72-masking-and-contextualization-with-yame-mask",
    
    "relUrl": "/docs/dsample.html#72-masking-and-contextualization-with-yame-mask"
  },"17": {
    "doc": "7. Mask Data",
    "title": "7. Mask Data",
    "content": " ",
    "url": "/YAME/docs/dsample.html",
    
    "relUrl": "/docs/dsample.html"
  },"18": {
    "doc": "3. Test Enrichment",
    "title": "3. Enrichment Testing with YAME",
    "content": "Test methylation enrichment across genomic features to identify biological associations. ",
    "url": "/YAME/docs/enrichment.html#3-enrichment-testing-with-yame",
    
    "relUrl": "/docs/enrichment.html#3-enrichment-testing-with-yame"
  },"19": {
    "doc": "3. Test Enrichment",
    "title": "Table of Contents",
    "content": ". | Overview . | What You’ll Learn | . | Prerequisites . | Unpack Reference Coordinates | . | Basic Workflow . | Step 1: Prepare Your Query Set | Step 2: Run Enrichment Testing | . | Understanding Output . | Interpreting Log2OddsRatio | Statistical Significance | . | Built-in Differential Calling | Enrichment with Custom Background . | Why Use a Custom Background? | Method 1: Using Mask (Recommended) | Method 2: Two-Column Format (Legacy) | . | Creating Custom Feature Files | Best Practices | Troubleshooting | Additional Resources | . ",
    "url": "/YAME/docs/enrichment.html#table-of-contents",
    
    "relUrl": "/docs/enrichment.html#table-of-contents"
  },"20": {
    "doc": "3. Test Enrichment",
    "title": "Overview",
    "content": "Enrichment testing identifies whether methylation patterns are statistically associated with specific genomic features (e.g., chromatin states, histone modifications, transcription factor binding sites, regulatory elements). YAME’s summary command performs rapid enrichment testing by comparing observed overlaps with expected overlaps based on background frequencies. What You’ll Learn . | Prepare differential methylation results for enrichment testing | Convert BED files to CX format | Perform enrichment testing with and without custom backgrounds | Interpret enrichment results and statistical significance | Use built-in differential calling functionality | . ",
    "url": "/YAME/docs/enrichment.html#overview",
    
    "relUrl": "/docs/enrichment.html#overview"
  },"21": {
    "doc": "3. Test Enrichment",
    "title": "Prerequisites",
    "content": "Before starting, ensure you have: . | Differential methylation results - A BED file containing significant CpG coordinates | bedtools - Install from bedtools.readthedocs.io | Reference CpG coordinates - Download .cr files from KYCG: . | hg38 reference | mm10 reference | . | Feature annotations - Download .cm feature files from KYCG (chromatin states, histone marks, etc.) | . Unpack Reference Coordinates . First, convert the reference .cr file to a BED format: . yame unpack cpg_nocontig.cr | gzip -c &gt; cpg_nocontig.bed.gz . ",
    "url": "/YAME/docs/enrichment.html#prerequisites",
    
    "relUrl": "/docs/enrichment.html#prerequisites"
  },"22": {
    "doc": "3. Test Enrichment",
    "title": "Basic Workflow",
    "content": "Step 1: Prepare Your Query Set . Convert your BED file of differential methylation sites to CX format. This involves: . | Sorting your BED file | Intersecting with reference CpG coordinates | Packing into binary format | . bedtools sort -i yourfile.bed | \\ bedtools intersect -a cpg_nocontig.bed.gz -b - -sorted -c | \\ cut -f4 | \\ yame pack -fb - &gt; yourfile.cg . Explanation: . | bedtools sort - Ensures BED file is sorted for efficient intersection | bedtools intersect -c - Counts overlaps with each reference CpG | cut -f4 - Extracts the CpG identifier column | yame pack -fb - Packs binary data (format b) into CX format | . Note: If your BED file is already sorted, you can skip the bedtools sort step. Step 2: Run Enrichment Testing . Test enrichment against genomic features using the -m option: . yame summary -m feature.cm yourfile.cg &gt; enrichment_results.txt . Feature files (.cm format) are available from KYCG and include: . | Chromatin states (ChromHMM, Roadmap Epigenomics) | Histone modifications (ChIP-seq peaks) | Transcription factor binding sites | Gene annotations (promoters, exons, introns, UTRs) | Regulatory elements (enhancers, insulators) | CpG islands and shores | Repetitive elements | . You can also create custom feature files using yame pack. ",
    "url": "/YAME/docs/enrichment.html#basic-workflow",
    
    "relUrl": "/docs/enrichment.html#basic-workflow"
  },"23": {
    "doc": "3. Test Enrichment",
    "title": "Understanding Output",
    "content": "The enrichment results contain the following columns: . | Column | Description | . | QFile | Query file name | . | Query | Sample name in query file | . | MFile | Feature/mask file name | . | Mask | Feature name being tested | . | N_univ | Total CpGs in universe (reference) | . | N_query | CpGs covered in query | . | N_mask | CpGs in feature | . | N_overlap | CpGs in both query and feature | . | Log2OddsRatio | Enrichment strength (log₂ scale) | . | Beta | Average methylation level in feature | . | Depth | Approximate coverage depth in feature | . Interpreting Log2OddsRatio . The log₂ odds ratio quantifies enrichment strength: . | ≥ 2.0 - Strong enrichment (4-fold or greater) | 1.0 - 2.0 - Moderate enrichment (2-4 fold) | 0.5 - 1.0 - Weak enrichment (1.4-2 fold) | ≈ 0 - No enrichment (random overlap) | &lt; 0 - Depletion (under-representation) | . Higher positive values indicate stronger association between your query set and the feature being tested. Statistical Significance . For formal significance testing, use the Fisher’s exact test implementation from the sesame R package: . # In R using sesame package library(sesame) # Map YAME output columns to Fisher's test parameters ND &lt;- N_mask # Feature size NQ &lt;- N_query # Query size NDQ &lt;- N_overlap # Overlap count NU &lt;- N_univ # Universe size # Perform Fisher's exact test testEnrichmentFisherN(ND, NQ, NDQ, NU) . An alternative R implementation is also available in the YAME GitHub repository under the R/ folder. ",
    "url": "/YAME/docs/enrichment.html#understanding-output",
    
    "relUrl": "/docs/enrichment.html#understanding-output"
  },"24": {
    "doc": "3. Test Enrichment",
    "title": "Built-in Differential Calling",
    "content": "YAME includes a built-in pairwise differential methylation caller: . yame pairwise -H 1 -c 10 \\ &lt;(yame subset sample1.cg sample1) \\ &lt;(yame subset sample2.cg sample2) \\ -o differential_output.cg . Parameters: . | -H 1 - Controls directionality (1 = hypermethylation in first sample) | -c 10 - Minimum coverage threshold (default: 10) | -o - Output file name | . Directionality options for -H: . | 1 - Hypermethylated in first sample | -1 - Hypomethylated in first sample | 0 - Either direction | . The output .cg file can be directly used for enrichment testing as described above. ",
    "url": "/YAME/docs/enrichment.html#built-in-differential-calling",
    
    "relUrl": "/docs/enrichment.html#built-in-differential-calling"
  },"25": {
    "doc": "3. Test Enrichment",
    "title": "Enrichment with Custom Background",
    "content": "Why Use a Custom Background? . The choice of background is crucial for accurate enrichment testing: . | Default behavior: Compares against all CpGs in the reference | Custom background: Compares against CpGs measured in your specific experiment | . Using a custom background (e.g., all CpGs covered by your assay) provides more accurate enrichment estimates by accounting for technical biases like: . | Array probe coverage | Sequencing accessibility | Coverage variation across genomic regions | . Method 1: Using Mask (Recommended) . The simplest approach uses the mask command to restrict analysis to your universe of interest: . yame mask -c query.cg universe.cg | \\ yame summary -m feature.cm - &gt; enrichment_results.txt . How it works: . | query.cg - Your differential methylation sites | universe.cg - All CpGs measured in your experiment | The mask operation restricts enrichment testing to only those CpGs in your universe | . Method 2: Two-Column Format (Legacy) . For more complex scenarios, you can create a two-column CX file: . Step 1: Intersect both query and background with reference . # Query set intersection bedtools intersect -a cpg_nocontig.bed.gz -b query.bed -sorted -c | \\ cut -f4 &gt; query_intersect.bed # Background set intersection bedtools intersect -a cpg_nocontig.bed.gz -b background.bed -sorted -c | \\ cut -f4 &gt; background_intersect.bed . Step 2: Combine into two-column format . paste query_intersect.bed background_intersect.bed | \\ yame pack -f6 - &gt; query_background.cg . Step 3: Run enrichment testing . yame summary -m feature.cm query_background.cg &gt; enrichment_results.txt . In this format: . | Column 1: Query set (sites of interest) | Column 2: Background/universe (all measured sites) | . ",
    "url": "/YAME/docs/enrichment.html#enrichment-with-custom-background",
    
    "relUrl": "/docs/enrichment.html#enrichment-with-custom-background"
  },"26": {
    "doc": "3. Test Enrichment",
    "title": "Creating Custom Feature Files",
    "content": "You can create your own feature annotations using yame pack. See the detailed example in the storage documentation. Quick example for a custom BED file: . bedtools intersect -a cpg_nocontig.bed.gz -b custom_features.bed -loj -sorted | \\ bedtools groupby -g 1-3 -c 7 -o first | \\ cut -f4 | \\ yame pack -f2 - &gt; custom_features.cm . ",
    "url": "/YAME/docs/enrichment.html#creating-custom-feature-files",
    
    "relUrl": "/docs/enrichment.html#creating-custom-feature-files"
  },"27": {
    "doc": "3. Test Enrichment",
    "title": "Best Practices",
    "content": ". | Always use sorted BED files - Ensures efficient bedtools operations | Match reference coordinates - Use the same genome build (hg38/mm10) throughout | Choose appropriate background - Use experiment-specific backgrounds when possible | Consider multiple testing correction - Apply FDR/Bonferroni when testing many features | Validate enrichments - Cross-reference with biological literature and databases | Check coverage requirements - Ensure sufficient coverage for meaningful statistics | . ",
    "url": "/YAME/docs/enrichment.html#best-practices",
    
    "relUrl": "/docs/enrichment.html#best-practices"
  },"28": {
    "doc": "3. Test Enrichment",
    "title": "Troubleshooting",
    "content": "Problem: “No overlaps found” . | Ensure genome builds match (hg38 vs hg19, mm10 vs mm9) | Verify BED files are properly formatted (0-based coordinates) | Check that CpG identifiers match the reference format | . Problem: “All features show similar enrichment” . | May indicate improper background selection | Consider using experiment-specific background | . Problem: “Very high log2 odds ratios (&gt;10)” . | May indicate low coverage or small sample sizes | Review N_overlap and N_mask values for adequacy | . ",
    "url": "/YAME/docs/enrichment.html#troubleshooting",
    
    "relUrl": "/docs/enrichment.html#troubleshooting"
  },"29": {
    "doc": "3. Test Enrichment",
    "title": "Additional Resources",
    "content": ". | KYCG hg38 features | KYCG mm10 features | bedtools documentation | sesame R package | . ",
    "url": "/YAME/docs/enrichment.html#additional-resources",
    
    "relUrl": "/docs/enrichment.html#additional-resources"
  },"30": {
    "doc": "3. Test Enrichment",
    "title": "3. Test Enrichment",
    "content": " ",
    "url": "/YAME/docs/enrichment.html",
    
    "relUrl": "/docs/enrichment.html"
  },"31": {
    "doc": "Fmt 0 – Binary Data",
    "title": "Format 0 – Binary Presence/Absence Data",
    "content": "Format 0 stores binary data, one bit per CpG, representing presence/absence or a simple methylation state. | Typical extension: .cg | Input: a vector of 0/1 values, one per CpG | Best for: . | Binary methylation calls | Presence/absence features | DMR indicators | Peak overlap masks | Cell-level binary CpG accessibility | . | . Format 0 is the smallest and fastest CX format: 8 CpGs per byte (~32× compression over text). ",
    "url": "/YAME/docs/formats/format0_binary.html#format-0--binary-presenceabsence-data",
    
    "relUrl": "/docs/formats/format0_binary.html#format-0--binary-presenceabsence-data"
  },"32": {
    "doc": "Fmt 0 – Binary Data",
    "title": "1. Input Requirements",
    "content": "Your input must be: . | Aligned to a CpG reference file (.cr, format 7) | Exactly one line per CpG | Each line containing 0 or 1 | . Example input (binary_data.txt): . 1 0 1 1 0 . Interpretation: . | 1 → presence, methylated, peak overlap, or “TRUE” | 0 → absence, unmethylated, no peak, or “FALSE” | . There is no NA value in format 0. Use Format 4 or 6 if you need NA or universe masking. ",
    "url": "/YAME/docs/formats/format0_binary.html#1-input-requirements",
    
    "relUrl": "/docs/formats/format0_binary.html#1-input-requirements"
  },"33": {
    "doc": "Fmt 0 – Binary Data",
    "title": "2. Packing to Format 0",
    "content": "2.1 From a raw 0/1 text vector . yame pack -fb binary_data.txt &gt; binary_output.cg . -fb selects Format 0 (b). 2.2 From BED features or presence/absence annotations . This is the canonical way to create a .cm/.cg mask from BED: . bedtools sort -i dmr_sites.bed \\ | bedtools intersect -a cpg_ref.bed.gz -b - -sorted -c \\ | cut -f4 \\ | yame pack -fb - &gt; dmr_binary.cg . Explanation: . | bedtools intersect -c counts how many times each CpG overlaps the BED input | cut -f4 extracts that count (0 or &gt;0) | yame pack -fb converts the result into a compressed CX file | . If a CpG overlaps ≥ 1 region, the value becomes 1; otherwise 0. ",
    "url": "/YAME/docs/formats/format0_binary.html#2-packing-to-format-0",
    
    "relUrl": "/docs/formats/format0_binary.html#2-packing-to-format-0"
  },"34": {
    "doc": "Fmt 0 – Binary Data",
    "title": "3. Unpacking Format 0",
    "content": "To get the 0/1 vector back: . yame unpack binary_output.cg | head . Example output: . 1 0 1 1 0 . Format 0 does not include sample-level metadata unless packed from multiple samples; YAME will unpack each sample sequentially if multiple samples exist. ",
    "url": "/YAME/docs/formats/format0_binary.html#3-unpacking-format-0",
    
    "relUrl": "/docs/formats/format0_binary.html#3-unpacking-format-0"
  },"35": {
    "doc": "Fmt 0 – Binary Data",
    "title": "4. Integration with Other YAME Commands",
    "content": "Format 0 integrates well with many downstream YAME tools. 4.1 yame summary . Format 0 is ideal for: . | Feature masks | Peak overlaps | Region presence indicators | . Example: . yame summary -m promoter.cm sample.cg . Outputs for each mask: . | N_mask | N_overlap | log2OddsRatio | Binary fraction (Beta) | Universe counts depending on the query | . 4.2 yame rowop . Useful operations on binary data: . # Sum across samples (pseudobulk for binary) yame rowop -o binasum multi_sample.cg &gt; pseudobulk.cg # Convert to binary string representation yame rowop -o binstring multi_sample.cg &gt; patterns.txt . binasum → format 3 output, with M = #1 votes and U = #0 votes. binstring → one binary string per row, e.g.: . 01011001 11100011 ... 4.3 yame dsample . Downsample a binary file to N “present” sites: . yame dsample -N 10000 -s 1 binary.cg &gt; dsampled.cg . For Format 0: . | Eligible sites are those with value 1 | Non-selected sites become 0 | . 4.4 yame rowsub . Subset rows from Format 0 the same as other formats: . # By row IDs yame rowsub -l row_ids.txt binary.cg &gt; subset.cg # By coordinate list and reference yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt binary.cg &gt; subset.cg # By mask yame rowsub -m promoter.cm binary.cg &gt; subset.promoters.cg . 4.5 yame mask . Format 0 plays especially well with yame mask: . # Mask out positions where mask == 1 yame mask binary.cg lowquality.cm -o masked_binary.cg . If you use -c, Format 0 can be contextualized into Format 6 to define a universe for sparse annotations. ",
    "url": "/YAME/docs/formats/format0_binary.html#4-integration-with-other-yame-commands",
    
    "relUrl": "/docs/formats/format0_binary.html#4-integration-with-other-yame-commands"
  },"36": {
    "doc": "Fmt 0 – Binary Data",
    "title": "5. When to Use Format 0 vs Other Formats",
    "content": "Use Format 0 when: . | Your data is intrinsically binary (e.g., peak/no-peak) | You want minimal storage footprint | You want maximum speed for summarization / enrichment | You are constructing feature files (promoters, enhancers, windows) | . Consider alternatives if: . | You need M/U counts → Format 3 | You need NA handling or fractions → Format 4 | You need structured query + universe semantics → Format 6 | . ",
    "url": "/YAME/docs/formats/format0_binary.html#5-when-to-use-format-0-vs-other-formats",
    
    "relUrl": "/docs/formats/format0_binary.html#5-when-to-use-format-0-vs-other-formats"
  },"37": {
    "doc": "Fmt 0 – Binary Data",
    "title": "6. Minimal End-to-End Example",
    "content": "# 1. Prepare CpG reference (only once) yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Create binary mask from BED peaks bedtools intersect -a cpg_ref.bed.gz -b H3K27ac.bed -sorted -c \\ | cut -f4 \\ | yame pack -fb - &gt; H3K27ac.cm # 3. Summarize enrichment of a methylation sample over H3K27ac peaks yame summary -m H3K27ac.cm sample.cg &gt; enrich.txt # 4. Subset sample to only CpGs in promoter regions yame rowsub -m promoters.cm sample.cg &gt; sample.promoters.cg # 5. Downsample the promoter mask to 5000 sites yame dsample -N 5000 promoters.cm &gt; promoters_5k.cm . ",
    "url": "/YAME/docs/formats/format0_binary.html#6-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format0_binary.html#6-minimal-end-to-end-example"
  },"38": {
    "doc": "Fmt 0 – Binary Data",
    "title": "Fmt 0 – Binary Data",
    "content": " ",
    "url": "/YAME/docs/formats/format0_binary.html",
    
    "relUrl": "/docs/formats/format0_binary.html"
  },"39": {
    "doc": "Fmt 1 - Integer Values",
    "title": "Format 1 – Integer Values with RLE Compression",
    "content": "Format 1 stores integer per-CpG values using run-length encoding (RLE) for efficient compression. It is ideal when your data consists of small integers repeated across long stretches of the genome. Examples: . | Per-CpG count values (e.g., motif hits, coverage statistics) | Fixed categorical encodings where numbers repeat often | Processed or discretized tracks that map 1 integer → 1 CpG | Anything that is not 0/1 (Format 0) and not M/U pairs (Format 3) | . ",
    "url": "/YAME/docs/formats/format1_integer.html#format-1--integer-values-with-rle-compression",
    
    "relUrl": "/docs/formats/format1_integer.html#format-1--integer-values-with-rle-compression"
  },"40": {
    "doc": "Fmt 1 - Integer Values",
    "title": "1. When to Use Format 1",
    "content": "Use Format 1 when: . | You have integer-valued data (0, 1, 2, 3…) | You expect long runs of identical values (e.g., 0 for most CpGs, intermittent 1’s or 2’s) | Storage size matters — Format 1 can give 10–100× compression for RLE-friendly data | You do not need: . | multiple values per CpG (use Format 3) | floating-point values (use Format 4) | category labels (use Format 2) | . | . ",
    "url": "/YAME/docs/formats/format1_integer.html#1-when-to-use-format-1",
    
    "relUrl": "/docs/formats/format1_integer.html#1-when-to-use-format-1"
  },"41": {
    "doc": "Fmt 1 - Integer Values",
    "title": "2. Input Requirements",
    "content": "Input must: . | Contain one integer per CpG | Be aligned to the reference coordinate file (.cr) | Match the reference length exactly | . Example input (int_values.txt): . 0 0 0 1 1 0 2 2 2 2 1 . Valid values: . | Any non-negative integer (0, 1, 2, …) | Larger integers are allowed but compress best when small and repeated | . Missing values are not supported — use Format 4 if you need NA. ",
    "url": "/YAME/docs/formats/format1_integer.html#2-input-requirements",
    
    "relUrl": "/docs/formats/format1_integer.html#2-input-requirements"
  },"42": {
    "doc": "Fmt 1 - Integer Values",
    "title": "3. Packing to Format 1",
    "content": "3.1 Pack from a text file . yame pack -f1 int_values.txt &gt; integer_track.cg . or using shorthand: . yame pack -f1 int_values.txt &gt; mytrack.cg . 3.2 Create integer tracks from BED (example: count overlapping regions) . bedtools intersect -a cpg_ref.bed.gz -b regions.bed -sorted -c \\ | cut -f4 \\ | yame pack -f1 - &gt; regions_count.cg . Explanation: . | bedtools intersect -c → count overlaps for each CpG | cut -f4 → extract the count | yame pack -f1 → compress into format 1 | . If your BED contains multiple types of annotations (e.g., peak strengths), you can convert those into integers before packing. ",
    "url": "/YAME/docs/formats/format1_integer.html#3-packing-to-format-1",
    
    "relUrl": "/docs/formats/format1_integer.html#3-packing-to-format-1"
  },"43": {
    "doc": "Fmt 1 - Integer Values",
    "title": "4. Unpacking Format 1",
    "content": "To recover integer values: . yame unpack integer_track.cg | head . Output: . 0 0 0 1 1 0 2 2 2 2 1 . Format 1 unpacks exactly what was packed (lossless RLE). ",
    "url": "/YAME/docs/formats/format1_integer.html#4-unpacking-format-1",
    
    "relUrl": "/docs/formats/format1_integer.html#4-unpacking-format-1"
  },"44": {
    "doc": "Fmt 1 - Integer Values",
    "title": "5. Integration with Other YAME Commands",
    "content": "Although Format 1 is less common than 0/2/3, it integrates with key YAME tools. 5.1 yame summary . You can compute summaries over masks: . yame summary -m features.cm integer_track.cg . Summary statistics for Format 1 include: . | N_query — number of CpGs with nonzero value | Beta — mean integer value inside each mask | Depth — unused (always NA) | Log2OddsRatio — enrichment of nonzero entries in each mask | . 5.2 yame rowsub . Format 1 supports all row subsetting methods: . # By index yame rowsub -l ids.txt integer_track.cg &gt; subset.cg # By coordinate list yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt integer_track.cg &gt; subset.cg # By mask yame rowsub -m promoter_mask.cm integer_track.cg &gt; promoter_subset.cg . 5.3 yame dsample . Downsampling for Format 1 uses the rule: . | Eligible sites = nonzero integers | Randomly keep N of them | Remaining sites become 0 | . Example: . yame dsample -N 20000 -s 123 int_track.cg &gt; int_track_20k.cg . 5.4 yame mask . You can mask out sites in Format 1 the same as Format 0 or 3: . yame mask int_track.cg low_quality.cm -o cleaned.cg . Masked CpGs become 0. ",
    "url": "/YAME/docs/formats/format1_integer.html#5-integration-with-other-yame-commands",
    
    "relUrl": "/docs/formats/format1_integer.html#5-integration-with-other-yame-commands"
  },"45": {
    "doc": "Fmt 1 - Integer Values",
    "title": "6. When Format 1 Is Not Appropriate",
    "content": "Choose another format if: . | You have two values per CpG → use Format 3 | You need floating-point values → use Format 4 | You need NA handling → use Format 4 | You have categorical labels → use Format 2 | You need sparse universe-aware binary representation → use Format 6 | . ",
    "url": "/YAME/docs/formats/format1_integer.html#6-when-format-1-is-not-appropriate",
    
    "relUrl": "/docs/formats/format1_integer.html#6-when-format-1-is-not-appropriate"
  },"46": {
    "doc": "Fmt 1 - Integer Values",
    "title": "7. Minimal End-to-End Example",
    "content": "# 1. Prepare reference CpGs (once per genome version) yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Compute coverage (example: count overlaps) bedtools intersect -a cpg_ref.bed.gz -b regions.bed -sorted -c \\ | cut -f4 \\ | yame pack -f1 - &gt; regions_track.cg # 3. Summarize over genomic features yame summary -m ChromHMM.cm regions_track.cg &gt; summary.txt # 4. Subset to promoter CpGs yame rowsub -m promoters.cm regions_track.cg &gt; promoter_track.cg # 5. Downsample high-intensity bins yame dsample -N 5000 regions_track.cg &gt; regions_5k.cg . Format 1 is a compact, efficient choice whenever your data is integer-valued and run-length compressible—a perfect middle ground between dense numeric matrices and coarse binary formats. ",
    "url": "/YAME/docs/formats/format1_integer.html#7-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format1_integer.html#7-minimal-end-to-end-example"
  },"47": {
    "doc": "Fmt 1 - Integer Values",
    "title": "Fmt 1 - Integer Values",
    "content": " ",
    "url": "/YAME/docs/formats/format1_integer.html",
    
    "relUrl": "/docs/formats/format1_integer.html"
  },"48": {
    "doc": "Fmt 2 - Categorical States",
    "title": "Format 2 – Categorical State Labels (Chromatin States / Genomic Features)",
    "content": "Format 2 stores categorical state labels, one per CpG, using run-length encoding optimized for repeated states across long genomic intervals. It is ideal for: . | ChromHMM 15-state / 25-state / full-stack segmentations | Genomic annotations (promoters, enhancers, gene bodies, exons) | Windowed features (100 kb bins, GC-content partitions) | Cell-type or experiment-specific categorical tracks | . Format 2 is the canonical YAME format for feature annotation files (.cm). ",
    "url": "/YAME/docs/formats/format2_states.html#format-2--categorical-state-labels-chromatin-states--genomic-features",
    
    "relUrl": "/docs/formats/format2_states.html#format-2--categorical-state-labels-chromatin-states--genomic-features"
  },"49": {
    "doc": "Fmt 2 - Categorical States",
    "title": "1. Characteristics of Format 2",
    "content": "Format 2 represents: . | One categorical label per CpG | Labels are stored as strings (e.g., TssA, TxFlnk, EnhW1, Promoter, Exon) | Internally compressed using run-length encoding: . | Identical labels across adjacent CpGs stored as a single block | . | Extremely compact for segment-based features (like ChromHMM) | . Typical extension: .cm Alternate shorthand: -fs (for “state”) . ",
    "url": "/YAME/docs/formats/format2_states.html#1-characteristics-of-format-2",
    
    "relUrl": "/docs/formats/format2_states.html#1-characteristics-of-format-2"
  },"50": {
    "doc": "Fmt 2 - Categorical States",
    "title": "2. Input Requirements",
    "content": "Input must: . | Have one state label per row | Contain the same number of rows as the reference CpG list | Match the ordering of the .cr reference file | . Example input (states.txt): . TssA TssA TxFlnk Tx Tx EnhG EnhW2 EnhW2 Quies Quies . Any string is accepted: . | Enhancer, Promoter, Intron | 1_TssA, 2_TssFlnk, 15_Quies | chr1_100kb_bin42 | . for missing / unassigned regions | . (Note: . is treated as a state label, not NA.) . ",
    "url": "/YAME/docs/formats/format2_states.html#2-input-requirements",
    
    "relUrl": "/docs/formats/format2_states.html#2-input-requirements"
  },"51": {
    "doc": "Fmt 2 - Categorical States",
    "title": "3. Packing to Format 2",
    "content": "3.1 From a text file . yame pack -f2 states.txt &gt; chrom_states.cm . Shorthand: . yame pack -fs states.txt &gt; chrom_states.cm . 3.2 From ChromHMM BED segmentation (recommended workflow) . Given ChromHMM segments: . chr1 10000 10400 1_TssA chr1 10400 10600 2_TssFlnk chr1 10600 10800 8_EnhW1 ... Convert to Format 2: . yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz zcat ChromHMM_segments.bed.gz \\ | bedtools sort \\ | bedtools intersect -a cpg_ref.bed.gz -b - -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; ChromHMM.cm . Explanation: . | -loj ensures all CpGs are retained, even in unannotated regions (unannotated sites get \".\") | groupby first resolves overlapping ChromHMM segments | . This is the standard method used in all YAME examples. 3.3 From generic genomic features . Any BED file can be converted into categorical states: . # For example, promoters, enhancers, exons... bedtools intersect -a cpg_ref.bed.gz -b promoters.bed -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; promoters.cm . Labels will be the region names (4th column). 3.4 From CPRA segments or window partitions . bedtools makewindows -g hg38.genome -w 100000 \\ | awk '{print $0\"\\tWin_\"NR}' \\ | bedtools intersect -a cpg_ref.bed.gz -b - -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; Win100kb.cm . ",
    "url": "/YAME/docs/formats/format2_states.html#3-packing-to-format-2",
    
    "relUrl": "/docs/formats/format2_states.html#3-packing-to-format-2"
  },"52": {
    "doc": "Fmt 2 - Categorical States",
    "title": "4. Unpacking Format 2",
    "content": "yame unpack chrom_states.cm | head . Example output: . TssA TssA TxFlnk Tx Tx EnhG EnhW2 EnhW2 Quies Quies . Unpacking simply returns the string labels originally packed (lossless). ",
    "url": "/YAME/docs/formats/format2_states.html#4-unpacking-format-2",
    
    "relUrl": "/docs/formats/format2_states.html#4-unpacking-format-2"
  },"53": {
    "doc": "Fmt 2 - Categorical States",
    "title": "5. Integration with Other YAME Commands",
    "content": "Format 2 plays a central role in feature-level analysis, especially enrichment testing. 5.1 yame summary . yame summary -m ChromHMM.cm sample.cg &gt; enrichment.txt . For each unique state label, YAME reports: . | N_mask — how many CpGs fall in that state | N_overlap — how many of those CpGs meet the query condition | Log2OddsRatio — enrichment of the state for the query | Beta — average methylation level (if query is Format 3) | Depth — depth (if available) | . Format 2 masks behave differently from binary masks: . | They produce one summary row per label, not a single aggregate. | . 5.2 yame rowsub . Extract all CpGs belonging to specific states: . # Extract only Enhancer-like states echo -e \"EnhW1\\nEnhW2\\nEnhG\" &gt; enhancer_states.txt yame rowsub -R cpg_nocontig.cr -L enhancer_states.txt ChromHMM.cm &gt; enhancer.cm . Or using Format 2’s built-in label mode: . # Add state name as first column in unpacked output yame rowsub -T -R cpg_nocontig.cr ChromHMM.cm &gt; labeled_output.cm . 5.3 yame mask . Convert Format 2 to binary mask: . # Mask all sites that are NOT enhancers yame mask ChromHMM.cm enhancer_mask.cx -v -o enhancer_only.cm . 5.4 yame dsample . Downsampling Format 2 keeps N non-“.” sites per sample: . yame dsample -N 50000 ChromHMM.cm &gt; ChromHMM_50k.cm . Unannotated sites (\".\") are typically treated as non-eligible. ",
    "url": "/YAME/docs/formats/format2_states.html#5-integration-with-other-yame-commands",
    
    "relUrl": "/docs/formats/format2_states.html#5-integration-with-other-yame-commands"
  },"54": {
    "doc": "Fmt 2 - Categorical States",
    "title": "6. When Not To Use Format 2",
    "content": "Avoid Format 2 if: . | You need numerical values → use Format 1, 3, or 4 | You need binary 0/1 → use Format 0 | You need structured query/universe sets → use Format 6 | You need NA handling or floating-point → use Format 4 | . Format 2 is for categorical labels only. ",
    "url": "/YAME/docs/formats/format2_states.html#6-when-not-to-use-format-2",
    
    "relUrl": "/docs/formats/format2_states.html#6-when-not-to-use-format-2"
  },"55": {
    "doc": "Fmt 2 - Categorical States",
    "title": "7. Minimal End-to-End ChromHMM Example",
    "content": "# 1. Prepare reference CpGs yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Convert ChromHMM segments to Format 2 zcat hg38_ChromHMM_25state.bed.gz \\ | bedtools sort \\ | bedtools intersect -a cpg_ref.bed.gz -b - -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; ChromHMM.cm # 3. Enrichment of methylation sample yame summary -m ChromHMM.cm sample.cg &gt; chromhmm_enrichment.txt # 4. Extract promoter-like states grep -E \"TssA|TssFlnk\" ChromHMM.cm &gt; promoters_of_interest.cm . Format 2 is the workhorse format for genomic annotations — especially ChromHMM — and is essential for all feature-based methylation analysis in YAME. ",
    "url": "/YAME/docs/formats/format2_states.html#7-minimal-end-to-end-chromhmm-example",
    
    "relUrl": "/docs/formats/format2_states.html#7-minimal-end-to-end-chromhmm-example"
  },"56": {
    "doc": "Fmt 2 - Categorical States",
    "title": "Fmt 2 - Categorical States",
    "content": " ",
    "url": "/YAME/docs/formats/format2_states.html",
    
    "relUrl": "/docs/formats/format2_states.html"
  },"57": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "Format 3 – Methylated &amp; Unmethylated Counts",
    "content": "Format 3 stores paired M/U (methylated/unmethylated) read counts per CpG from bisulfite-based assays (e.g., WGBS, RRBS). | Typical extension: .cg | Input: two integers per CpG: M (methylated) and U (unmethylated) | Best for: high-coverage sequencing where you want to preserve read counts and coverage | . ",
    "url": "/YAME/docs/formats/format3_mu.html#format-3--methylated--unmethylated-counts",
    
    "relUrl": "/docs/formats/format3_mu.html#format-3--methylated--unmethylated-counts"
  },"58": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "1. Input Requirements",
    "content": "Before packing into format 3, your data must be: . | Aligned to a CpG reference coordinate file (format 7, e.g. cpg_nocontig.cr) | One row per CpG, in the same order and of the same length as the reference | Each row: two non-negative integers: M and U | . Example input (mu_counts.txt): . 12 3 8 8 0 15 20 2 0 0 5 10 . Interpretation per line: . | Column 1: methylated count (M) | Column 2: unmethylated count (U) | Both must be ≥ 0; M = U = 0 means “no coverage / missing” | . ",
    "url": "/YAME/docs/formats/format3_mu.html#1-input-requirements",
    
    "relUrl": "/docs/formats/format3_mu.html#1-input-requirements"
  },"59": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "2. Packing to Format 3",
    "content": "2.1 From an aligned M/U table . If you already have a table of M U pairs, aligned to the CpG reference: . yame pack -f3 mu_counts.txt &gt; sample.cg . This creates a compressed .cg file in format 3. 2.2 From BED-like methylation calls . If your pipeline outputs per-CpG counts as BED: . # mu_calls.bed columns (example): # chr start end M U bedtools intersect -a cpg_ref.bed.gz -b mu_calls.bed -loj -sorted \\ | awk '{ if ($8 == \".\") print \"0\\t0\"; else print $8\"\\t\"$9 }' \\ | yame pack -f3 - &gt; sample.cg . Key points: . | -loj (left outer join) ensures every reference CpG appears exactly once. | CpGs not covered in mu_calls.bed are assigned 0 0 (no coverage). | The awk produces two columns (M, U) suitable for yame pack -f3. | . ",
    "url": "/YAME/docs/formats/format3_mu.html#2-packing-to-format-3",
    
    "relUrl": "/docs/formats/format3_mu.html#2-packing-to-format-3"
  },"60": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "3. Unpacking Format 3",
    "content": "By default, yame unpack converts M/U counts into beta and coverage: . yame unpack sample.cg | head . Example output: . 0.800 15 0.500 16 0.000 15 0.909 22 NA 0 0.333 15 . Columns: . | Beta – M / (M + U); NA if M + U == 0 | Coverage – M + U | . You can filter by minimum coverage with -f: . # Only output CpGs with coverage ≥ 5 yame unpack -f 5 sample.cg &gt; sample_cov5.txt . This is convenient for QC and downstream tools that expect beta + coverage. ",
    "url": "/YAME/docs/formats/format3_mu.html#3-unpacking-format-3",
    
    "relUrl": "/docs/formats/format3_mu.html#3-unpacking-format-3"
  },"61": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "4. Integration with Other YAME Commands",
    "content": "Format 3 works with most downstream operations: . 4.1 yame summary . yame summary sample.cg yame summary -m feature.cm sample.cg . summary will compute per-sample and per-feature: . | Number of CpGs in universe / query / mask | Overlap counts and log2 odds ratio | Average beta in feature regions | Average depth in feature regions | . 4.2 yame rowop (row-wise operations) . Some common operations on format 3: . # Per-CpG mean beta across samples yame rowop -o mean sample.cg &gt; mean_beta.tsv # Per-CpG standard deviation of beta across samples yame rowop -o std sample.cg &gt; beta_std.tsv # Sum M and U across samples (true pseudobulk counts) yame rowop -o musum sample.cg bulk.cg # Binarize and sum (vote-based pseudobulk) yame rowop -o binasum -c 3 sample.cg bulk_binasum.cg . Quick interpretations: . | -o mean For each CpG, computes the mean beta across samples that have coverage ≥ -c (default 1). Output: beta_mean n_samples_used. | -o std For each CpG, computes standard deviation of beta across samples with coverage ≥ -c. Output: beta_sd n_samples_used. | -o musum Sums M and U directly across samples, preserving counts. Output is a new format 3 .cg file. | -o binasum Converts each sample to a binary call by comparing M vs U (and coverage ≥ -c), then counts methylated vs unmethylated “votes” across samples. | . 4.3 yame dsample (downsampling) . You can create downsampled versions of format 3 data to simulate reduced coverage or increased sparsity: . # Keep 50,000 covered CpGs per sample, fixed seed yame dsample -N 50000 -s 1 sample.cg &gt; sample_N50k.cg . Behavior for format 3: . | Eligible sites: CpGs with M + U &gt; 0 | Randomly selects up to N eligible sites; the rest are masked by setting M = U = 0. | . 4.4 yame rowsub (row subsetting) . Subset CpGs (rows) from a format 3 file: . # By index list yame rowsub -l row_ids.txt sample.cg &gt; subset.cg # By coordinate list and row coordinate file yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt sample.cg &gt; subset.cg # By binary mask yame rowsub -m mask.cx sample.cg &gt; masked_subset.cg . The output remains format 3. ",
    "url": "/YAME/docs/formats/format3_mu.html#4-integration-with-other-yame-commands",
    
    "relUrl": "/docs/formats/format3_mu.html#4-integration-with-other-yame-commands"
  },"62": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "5. When to Use Format 3 (vs Other Formats)",
    "content": "Choose Format 3 when: . | You have bisulfite sequencing data with per-CpG counts. | You care about coverage and want to model uncertainty (beta at low coverage vs high coverage). | You want the option to derive beta, binary calls, or more complex statistics later. | . Consider other formats when: . | You only need beta values: use Format 4 for more compact storage. | You want only 0/1 calls: use Format 0. | You’re working with sparse single-cell binary data with an explicit universe: consider Format 6. | . ",
    "url": "/YAME/docs/formats/format3_mu.html#5-when-to-use-format-3-vs-other-formats",
    
    "relUrl": "/docs/formats/format3_mu.html#5-when-to-use-format-3-vs-other-formats"
  },"63": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "6. Minimal End-to-End Example",
    "content": "# 1. Prepare reference CpG coordinates (once per genome/build) yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Align M/U calls to reference CpGs bedtools intersect -a cpg_ref.bed.gz -b mu_calls.bed -loj -sorted \\ | awk '{ if ($8 == \".\") print \"0\\t0\"; else print $8\"\\t\"$9 }' \\ | yame pack -f3 - &gt; sample.cg # 3. QC and summary yame info sample.cg yame summary sample.cg # 4. Export beta and coverage for external tools (coverage ≥ 10) yame unpack -f 10 sample.cg &gt; sample_cov10.txt . This is the typical pattern for ingesting WGBS/RRBS data into YAME using Format 3. ",
    "url": "/YAME/docs/formats/format3_mu.html#6-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format3_mu.html#6-minimal-end-to-end-example"
  },"64": {
    "doc": "Fmt 3 – M & U Counts",
    "title": "Fmt 3 – M & U Counts",
    "content": " ",
    "url": "/YAME/docs/formats/format3_mu.html",
    
    "relUrl": "/docs/formats/format3_mu.html"
  },"65": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "Format 4 – Continuous Methylation Fractions (Beta Values)",
    "content": "Format 4 stores continuous numeric values, typically representing: . | DNA methylation beta values (0.0–1.0) | Methylation fractions computed from M/U counts | Imputed methylation levels | Normalized array intensities converted to β-values | Any numeric score per CpG where NA is allowed | . Format 4 is the right choice when you need floating-point precision and optional NA handling. ",
    "url": "/YAME/docs/formats/format4_beta.html#format-4--continuous-methylation-fractions-beta-values",
    
    "relUrl": "/docs/formats/format4_beta.html#format-4--continuous-methylation-fractions-beta-values"
  },"66": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "1. Characteristics of Format 4",
    "content": "Format 4 provides: . | One float per CpG | Optional NA values | Compression using “NA + run-length encoding” (NA-RLE) | Very efficient storage for array data and imputed datasets | . Typical extension: .cg Format flag: -f4 . ",
    "url": "/YAME/docs/formats/format4_beta.html#1-characteristics-of-format-4",
    
    "relUrl": "/docs/formats/format4_beta.html#1-characteristics-of-format-4"
  },"67": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "2. Input Requirements",
    "content": "Input must have: . | One row per CpG | A value in one of the following forms: . | Float between 0 and 1 (inclusive) | \"NA\" meaning missing | Scientific notation allowed (e.g., 3e-2) | . | . Example input (beta_values.txt): . 0.75 0.33 0.88 NA 0.50 0.92 . Valid input also includes: . 0 1 0.12345 0.9999 . ",
    "url": "/YAME/docs/formats/format4_beta.html#2-input-requirements",
    
    "relUrl": "/docs/formats/format4_beta.html#2-input-requirements"
  },"68": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "3. Packing to Format 4",
    "content": "3.1 Pack from a simple text vector . yame pack -f4 beta_values.txt &gt; beta.cg . 3.2 From array data (e.g., Illumina 450k, EPIC) . Suppose you have a ProbeID → Beta table: . # array_data.txt example: # cg00001234 0.45 # cg00002456 0.71 # cg00003522 NA . Convert to Format 4: . # Intersect array probes with CpG reference join -1 4 -2 1 -t$'\\t' \\ &lt;(sort -k4,4 cpg_ref_with_ids.bed) \\ &lt;(sort -k1,1 array_data.txt) \\ | sort -k2,2 -k3,3n \\ | cut -f5 \\ | yame pack -f4 - &gt; array_sample.cg . 3.3 From M/U counts (Format 3 → Format 4) . To convert a Format 3 .cg into beta values: . yame unpack -a sample.cg &gt; beta_cov.txt # outputs beta and coverage cut -f1 beta_cov.txt \\ | yame pack -f4 - &gt; sample.beta.cg . Or directly: . yame unpack sample.cg | cut -f1 | yame pack -f4 - &gt; sample.beta.cg . ",
    "url": "/YAME/docs/formats/format4_beta.html#3-packing-to-format-4",
    
    "relUrl": "/docs/formats/format4_beta.html#3-packing-to-format-4"
  },"69": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "4. Unpacking Format 4",
    "content": "yame unpack beta.cg | head . Example output: . 0.75 0.33 0.88 NA 0.50 0.92 . Format 4 unpacks to a single float value per line, identical to input (lossless). ",
    "url": "/YAME/docs/formats/format4_beta.html#4-unpacking-format-4",
    
    "relUrl": "/docs/formats/format4_beta.html#4-unpacking-format-4"
  },"70": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "5. Integration with Other YAME Commands",
    "content": ". 5.1 yame summary . Format 4 supports enrichment and window summarization: . yame summary -m features.cm beta.cg . Outputs include: . | Beta → mean of numeric values inside the mask | Depth → always “NA” for Format 4 | N_query → number of non-NA CpGs | N_overlap → number of CpGs inside mask with non-NA values | . 5.2 yame rowop . Useful numeric operations: . # Per-CpG mean across samples yame rowop -o mean beta_multi.cg &gt; mean.tsv # Per-CpG standard deviation across samples yame rowop -o std beta_multi.cg &gt; std.tsv . Format 4 behaves identically to Format 3 for mean/std, except that NA is allowed. 5.3 yame dsample . Downsampling Format 4 is based on non-NA values: . yame dsample -N 50000 beta.cg &gt; beta_50k.cg . | Eligible: CpGs where value is not NA | Non-selected: set to NA | . 5.4 yame rowsub . # Subset by mask yame rowsub -m promoter.cm beta.cg &gt; beta.promoters.cg # Subset by coordinate list yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt beta.cg &gt; subset.cg . 5.5 yame mask . Masking Format 4 replaces masked positions with NA: . yame mask beta.cg lowqual.cx -o beta.filtered.cg . ",
    "url": "/YAME/docs/formats/format4_beta.html#5-integration-with-other-yame-commands",
    
    "relUrl": "/docs/formats/format4_beta.html#5-integration-with-other-yame-commands"
  },"71": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "6. When NOT to Use Format 4",
    "content": "Use a different format if: . | You need M/U counts → Format 3 | Your values are binary → Format 0 | Your labels are categorical → Format 2 | You need a structured universe/query → Format 6 | You need NA-free numeric integers → Format 1 | . Format 4 is the only format allowing floating-point values. ",
    "url": "/YAME/docs/formats/format4_beta.html#6-when-not-to-use-format-4",
    
    "relUrl": "/docs/formats/format4_beta.html#6-when-not-to-use-format-4"
  },"72": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "7. Minimal End-to-End Example",
    "content": "# 1. Prepare CPM reference yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Convert array data to Format 4 join -1 4 -2 1 -t$'\\t' \\ &lt;(sort -k4,4 cpg_ref_with_ids.bed) \\ &lt;(sort -k1,1 array_data.txt) \\ | sort -k2,2 -k3,3n \\ | cut -f5 \\ | yame pack -f4 - &gt; array_sample.cg # 3. Summarize across genomic features yame summary -m ChromHMM.cm array_sample.cg &gt; array_enrichment.txt # 4. Extract CpGs for gene promoters yame rowsub -m promoters.cm array_sample.cg &gt; promoter_beta.cg # 5. Replace low-confidence CpGs with NA using mask yame mask array_sample.cg lowconf.cx -o array_filtered.cg . Format 4 is the default for all continuous methylation values, including array β-values and imputed sequencing fractions, with full support for NA, summarization, subsetting, and efficient compression. ",
    "url": "/YAME/docs/formats/format4_beta.html#7-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format4_beta.html#7-minimal-end-to-end-example"
  },"73": {
    "doc": "Fmt 4 – Fraction Values",
    "title": "Fmt 4 – Fraction Values",
    "content": " ",
    "url": "/YAME/docs/formats/format4_beta.html",
    
    "relUrl": "/docs/formats/format4_beta.html"
  },"74": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "Format 5 – Ternary Differential Methylation Calls",
    "content": "Format 5 stores a single ternary value per CpG, typically representing: . | 0 → hypomethylated | 1 → unchanged / not significant | 2 → hypermethylated | . This format is compact (2 bits per CpG), extremely fast to read, and ideal for storing categorical differential methylation results. ",
    "url": "/YAME/docs/formats/format5_ternary.html#format-5--ternary-differential-methylation-calls",
    
    "relUrl": "/docs/formats/format5_ternary.html#format-5--ternary-differential-methylation-calls"
  },"75": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "1. When to Use Format 5",
    "content": "Use Format 5 when your data: . | Represents three discrete states (e.g., {hypo, unchanged, hyper}) | Comes from: . | differential methylation analysis (DMRs) | EWAS with discretized outcomes | statistical calling pipelines | . | Does not require: . | continuous values (use Format 4) | counts (use Format 3) | categorical labels of arbitrary strings (use Format 2) | . | . Format 5 is ideal for large differential methylation compendia because it’s tiny and fast. ",
    "url": "/YAME/docs/formats/format5_ternary.html#1-when-to-use-format-5",
    
    "relUrl": "/docs/formats/format5_ternary.html#1-when-to-use-format-5"
  },"76": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "2. Input Requirements",
    "content": "Input must include: . | One line per CpG | A value from the set {0, 1, 2} | . Example input (diff_calls.txt): . 0 1 2 1 0 2 . Interpretation (default): . | Value | Meaning | . | 0 | Hypomethylated | . | 1 | No change | . | 2 | Hypermethylated | . (These semantic labels are user-defined; YAME treats them as integers.) . ",
    "url": "/YAME/docs/formats/format5_ternary.html#2-input-requirements",
    
    "relUrl": "/docs/formats/format5_ternary.html#2-input-requirements"
  },"77": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "3. Packing to Format 5",
    "content": "3.1 Pack from text . yame pack -f5 diff_calls.txt &gt; differential.cg . 3.2 Generate Format 5 from an external DMR pipeline . If your DMR results are in BED or TSV, convert them into a CpG-level ternary track by intersecting with reference CpGs: . # Example: columns = chr, start, end, diff_call (0/1/2) bedtools intersect -a cpg_ref.bed.gz -b dmr_calls.bed -loj -sorted \\ | awk '{ if ($8 == \".\") print \"1\"; else print $8 }' \\ | yame pack -f5 - &gt; diff.cg . Interpretation: . | Sites lacking a call become 1 (unchanged) (You can change this behavior depending on your workflow.) | . ",
    "url": "/YAME/docs/formats/format5_ternary.html#3-packing-to-format-5",
    
    "relUrl": "/docs/formats/format5_ternary.html#3-packing-to-format-5"
  },"78": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "4. Unpacking Format 5",
    "content": "yame unpack differential.cg | head . Output: . 0 1 2 1 0 2 . Format 5 unpacks to integers exactly as originally stored. ",
    "url": "/YAME/docs/formats/format5_ternary.html#4-unpacking-format-5",
    
    "relUrl": "/docs/formats/format5_ternary.html#4-unpacking-format-5"
  },"79": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "5. Integration with YAME Commands",
    "content": "Format 5 integrates with major YAME tools. 5.1 yame summary . Use Format 5 to compute enrichment of hypo / hyper states across features: . yame summary -m ChromHMM.cm differential.cg &gt; diff_summary.txt . Behavior: . | N_query = number of CpGs with non-1 values (or all CpGs, depending on interpretation) | N_overlap = number of CpGs in the mask with relevant values | Beta = mean ternary state (0–2) across the mask (This is typically interpretable as “direction of change”) | Depth = NA (unused) | . If you want to treat only hypo (0) vs hyper (2) as binary, you may preprocess the data. 5.2 yame rowop . Format 5 supports row-wise aggregation across multiple samples. Summing ternary states: . yame rowop -o binasum differential_multi.cg &gt; diff_votes.cg . Interpretation: . | Converts: . | 0 → unmethylated vote | 2 → methylated vote | 1 → ambiguous (ignored) | . | Produces a Format 3 pseudobulk count file. | . Mean or standard deviation: . yame rowop -o mean differential_multi.cg &gt; mean_state.tsv yame rowop -o std differential_multi.cg &gt; state_variability.tsv . Output: . | mean: average state (0–2) across samples | std: variability in differential calling | . 5.3 yame dsample . Downsampling Format 5 retains N non-1 CpGs per sample: . yame dsample -N 10000 diff.cg &gt; diff_10k.cg . Rules: . | Eligible = CpGs where state ≠ 1 (i.e., changes) | Non-selected = set to 1 (unchanged) | . 5.4 yame rowsub . # Extract CpGs that are differential yame rowsub -m diff_mask.cx diff.cg &gt; diff_only.cg # Extract genomic subregions yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt diff.cg &gt; subset.cg . 5.5 yame mask . To mask out (remove) certain CpGs: . yame mask diff.cg lowqual_mask.cx -o filtered_diff.cg . Masked values become 1 (interpreted as “not differential”). Or use -v to invert mask logic. ",
    "url": "/YAME/docs/formats/format5_ternary.html#5-integration-with-yame-commands",
    
    "relUrl": "/docs/formats/format5_ternary.html#5-integration-with-yame-commands"
  },"80": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "6. When Not to Use Format 5",
    "content": "Choose a different format if: . | You need floating-point values → Format 4 | You need per-CpG M/U counts → Format 3 | You need arbitrary string labels → Format 2 | You need a sparse binary representation with an explicit universe → Format 6 | . Format 5 is strictly for three-state encoded data. ",
    "url": "/YAME/docs/formats/format5_ternary.html#6-when-not-to-use-format-5",
    
    "relUrl": "/docs/formats/format5_ternary.html#6-when-not-to-use-format-5"
  },"81": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "7. Minimal End-to-End Example",
    "content": "# 1. Prepare reference CpGs yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Convert DMR calls into ternary CpG-level states bedtools intersect -a cpg_ref.bed.gz -b dmr_calls.bed -loj -sorted \\ | awk '{ if ($8 == \".\") print \"1\"; else print $8 }' \\ | yame pack -f5 - &gt; diff.cg # 3. Evaluate enrichment of differential states across ChromHMM annotations yame summary -m ChromHMM.cm diff.cg &gt; diff_enrichment.txt # 4. Extract hypermethylated CpGs (state = 2) grep \"^2$\" diff.cg &gt; hyper_sites.txt # 5. Downsample for benchmarking yame dsample -N 20000 diff.cg &gt; diff_20k.cg . Format 5 is the compact, efficient format for discrete differential methylation calls, offering excellent compression and fast downstream feature-based analysis. ",
    "url": "/YAME/docs/formats/format5_ternary.html#7-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format5_ternary.html#7-minimal-end-to-end-example"
  },"82": {
    "doc": "Fmt 5 – Differential Calls",
    "title": "Fmt 5 – Differential Calls",
    "content": " ",
    "url": "/YAME/docs/formats/format5_ternary.html",
    
    "relUrl": "/docs/formats/format5_ternary.html"
  },"83": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "Format 6 – Query &amp; Universe (Boolean Sparse Representation)",
    "content": "Format 6 encodes two complementary boolean vectors for each CpG: . | SET bit → CpG is included in the query | UNIVERSE bit → CpG belongs to the background universe | . This format is essential for: . | Enrichment testing (query vs universe) | Sparse single-cell methylation (accessible universe + binary call) | Binary presence/absence with explicit context | Efficient representation of cell-specific CpG availability | . Format 6 allows YAME to know both the methylated/unmethylated call and whether the CpG is even in scope for that sample. ",
    "url": "/YAME/docs/formats/format6_sparse.html#format-6--query--universe-boolean-sparse-representation",
    
    "relUrl": "/docs/formats/format6_sparse.html#format-6--query--universe-boolean-sparse-representation"
  },"84": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "1. When to Use Format 6",
    "content": "Use Format 6 when: . | You want to run enrichment tests (yame summary -m mask.cm sample.cx) | You want to represent sparse CpG coverage per sample (e.g., scWGBS) | You want a contextualized binary representation in which: . | CpG exists in the cell’s “universe” | CpG is methylated/unmethylated inside that universe | . | . Format 6 is the only CX format that explicitly encodes two bits per CpG. This makes it the natural fit for: . | Single-cell bisulfite data | Sparse pseudo-bulk models | Query/background analyses | Fine-grained masking workflows (e.g., yame mask -c) | . ",
    "url": "/YAME/docs/formats/format6_sparse.html#1-when-to-use-format-6",
    
    "relUrl": "/docs/formats/format6_sparse.html#1-when-to-use-format-6"
  },"85": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "2. Input Requirements",
    "content": "Input must contain two columns, each with 0 or 1: . &lt;QueryBit&gt; &lt;UniverseBit&gt; . Example: . 1 1 # in query, in universe 0 1 # not in query, in universe 1 1 # in query, in universe 0 0 # outside the universe entirely . Meaning: . | Query | Universe | Interpretation | . | 1 | 1 | CpG is part of query set | . | 0 | 1 | CpG is in universe but not part of query | . | 0 | 0 | CpG should be ignored entirely | . | 1 | 0 | Invalid (cannot be in query if not in universe) | . YAME enforces this logic automatically when packing/masking. ",
    "url": "/YAME/docs/formats/format6_sparse.html#2-input-requirements",
    
    "relUrl": "/docs/formats/format6_sparse.html#2-input-requirements"
  },"86": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "3. Packing to Format 6",
    "content": "3.1 Packing from a text file with two columns . yame pack -f6 query_universe.txt &gt; sample.cx . 3.2 Using BED inputs (query and universe tracks) . Generate a query mask: . bedtools intersect -a cpg_ref.bed.gz -b query_peaks.bed -sorted -c \\ | cut -f4 &gt; query.txt . Generate a universe mask: . bedtools intersect -a cpg_ref.bed.gz -b regions_accessible.bed -sorted -c \\ | cut -f4 &gt; universe.txt . Combine to two columns: . paste query.txt universe.txt | \\ awk '{print ($1&gt;0?1:0) \"\\t\" ($2&gt;0?1:0)}' \\ | yame pack -f6 - &gt; query.cx . 3.3 From Format 0 + Universe mask using yame mask -c (recommended) . If you already have a binary vector (Format 0), and a universe mask: . # binary input: 1 = methylated, 0 = unmethylated yame mask -c input_binary.cx universe_mask.cx -o contextual.cx . Rules: . | Universe = mask’s 1s | Query = input’s binary values inside universe | . This is common in single-cell pipelines. ",
    "url": "/YAME/docs/formats/format6_sparse.html#3-packing-to-format-6",
    
    "relUrl": "/docs/formats/format6_sparse.html#3-packing-to-format-6"
  },"87": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "4. Unpacking Format 6",
    "content": "yame unpack sample.cx | head . The output has two columns: . &lt;Query&gt; &lt;Universe&gt; 1 1 0 1 1 1 0 0 ... Matching the original input format. ",
    "url": "/YAME/docs/formats/format6_sparse.html#4-unpacking-format-6",
    
    "relUrl": "/docs/formats/format6_sparse.html#4-unpacking-format-6"
  },"88": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "5. Integration with YAME Commands",
    "content": "Format 6 integrates deeply with the core statistical logic of YAME. 5.1 yame summary . Format 6 is designed for enrichment analysis: . yame summary -m feature.cm sample.cx . Interpretation: . | N_univ = number of CpGs where UniverseBit = 1 | N_query = number of CpGs with both UniverseBit = 1 and QueryBit = 1 | N_mask = size of feature | N_overlap = how many CpGs are (in query) AND (in mask) | Log2OddsRatio = enrichment of query inside mask | Beta = fraction of QueryBit = 1 among universe CpGs within mask | Depth = NA (Format 6 has no coverage) | . This is the recommended representation for: . | Comparing different CpG subsets | Representing sparse single-cell methylomes | Querying binary signatures within genomic features | . 5.2 yame rowop . Useful operations: . # Binary summation across samples yame rowop -o binasum multi.cx &gt; pseudobulk.cg # Convert to binary string yame rowop -o binstring multi.cx &gt; patterns.txt . Rules: . | Query bit → methylated/unmethylated value | Universe bit → determines coverage; if Universe = 0, skip site entirely | . 5.3 yame dsample . Downsampling Format 6: . yame dsample -N 10000 sample.cx &gt; sample_10k.cx . Rules: . | Eligible sites = UniverseBit = 1 | Randomly keep N of them per sample | Non-selected → UniverseBit set to 0; QueryBit cleared | . This is extremely useful for benchmarking single-cell sparsity. 5.4 yame rowsub . Format 6 supports all selection methods: . # Subset by mask yame rowsub -m promoters.cm sample.cx &gt; subset.cx # Coordinate lists yame rowsub -R cpg_nocontig.cr -L CpG_sites.txt sample.cx &gt; subset.cx . 5.5 yame mask (contextualization mode) . # Convert binary format 0 → format 6 with a universe mask yame mask -c binary.cx universe.cx -o out.cx . | Universe bits taken from mask | Query bits taken from binary vector | Sites outside universe become NA-like (Universe = 0) | . This workflow is central to building high-quality single-cell methylome objects. ",
    "url": "/YAME/docs/formats/format6_sparse.html#5-integration-with-yame-commands",
    
    "relUrl": "/docs/formats/format6_sparse.html#5-integration-with-yame-commands"
  },"89": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "6. When NOT to Use Format 6",
    "content": "Use a different format if: . | You need floating-point methylation values → Format 4 | You need M/U counts → Format 3 | You have categorical labels → Format 2 | You need simple 0/1 binary without context → Format 0 | . Format 6 is best when context matters (universe vs query). ",
    "url": "/YAME/docs/formats/format6_sparse.html#6-when-not-to-use-format-6",
    
    "relUrl": "/docs/formats/format6_sparse.html#6-when-not-to-use-format-6"
  },"90": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "7. Minimal End-to-End Example",
    "content": "# 1. Prepare reference CpGs yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Build a universe mask (e.g., accessible CpGs) bedtools intersect -a cpg_ref.bed.gz -b ATAC.bed -sorted -c \\ | cut -f4 \\ | yame pack -fb - &gt; universe.cx # 3. Build a binary methylation call track bedtools intersect -a cpg_ref.bed.gz -b methylated_calls.bed -sorted -c \\ | cut -f4 \\ | yame pack -fb - &gt; binary.cx # 4. Contextualize into Format 6 yame mask -c binary.cx universe.cx -o cell.cx # 5. Run enrichment against ChromHMM yame summary -m ChromHMM.cm cell.cx &gt; enrich.txt # 6. Downsample to 50k accessible CpGs yame dsample -N 50000 cell.cx &gt; cell_50k.cx . Format 6 is the essential representation for sparse binary methylation, especially in single-cell analyses and feature-level enrichment testing. It is compact, expressive, and foundational for high-performance YAME workflows. ``` . ",
    "url": "/YAME/docs/formats/format6_sparse.html#7-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format6_sparse.html#7-minimal-end-to-end-example"
  },"91": {
    "doc": "Fmt 6 – Query & Universe",
    "title": "Fmt 6 – Query & Universe",
    "content": " ",
    "url": "/YAME/docs/formats/format6_sparse.html",
    
    "relUrl": "/docs/formats/format6_sparse.html"
  },"92": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "Format 7 – CpG Reference Coordinate Files (.cr)",
    "content": "Format 7 provides the reference coordinate system for all .cx files in YAME. Every .cg / .cm file—regardless of format (0–6)—must match the row count and ordering of a Format 7 reference file. This makes Format 7 the backbone of the entire YAME infrastructure. A .cr file contains: . | Chromosome | Start position | End position | CpG ID (e.g., chr1_10469) | Efficiently delta-encoded and BGZF-compressed for fast access | . ",
    "url": "/YAME/docs/formats/format7_reference.html#format-7--cpg-reference-coordinate-files-cr",
    
    "relUrl": "/docs/formats/format7_reference.html#format-7--cpg-reference-coordinate-files-cr"
  },"93": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "1. Purpose of Format 7",
    "content": "Format 7 answers two fundamental questions: . | Where is CpG row i located in the genome? | What row corresponds to genomic coordinate (chr, pos)? | . All downstream YAME operations assume that every sample is aligned to the same .cr file. Typical uses: . | Establish genome-wise ordering of CpGs | Provide coordinate context to summary operations | Support indexing, subsetting, windowing, and masking | Serve as the base for feature creation (format 2) | Ensure consistent row alignment across multi-sample .cx files | . ",
    "url": "/YAME/docs/formats/format7_reference.html#1-purpose-of-format-7",
    
    "relUrl": "/docs/formats/format7_reference.html#1-purpose-of-format-7"
  },"94": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "2. What Format 7 Contains",
    "content": "Each row represents one CpG: . chr1 10468 10469 chr1_10469 chr1 10470 10471 chr1_10471 chr1 10483 10484 chr1_10484 ... Columns: . | Chromosome | Start (0-based BED convention) | End (start+1) | Name (or ID), usually chr_pos1 | . Internally, YAME stores: . | Delta-compressed positions | RLE encoding of chromosome boundaries | A name dictionary | . This makes .cr much smaller than a BED. ",
    "url": "/YAME/docs/formats/format7_reference.html#2-what-format-7-contains",
    
    "relUrl": "/docs/formats/format7_reference.html#2-what-format-7-contains"
  },"95": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "3. Packing to Format 7",
    "content": "3.1 From a BED file of CpG sites . yame pack -f7 cpg_coords.bed &gt; cpg_reference.cr . Input BED must contain at least the first 3 columns; the 4th is optional but recommended. Example input (cpg_coords.bed): . chr1 10468 10469 chr1_10469 chr1 10470 10471 chr1_10471 chr1 10483 10484 chr1_10484 . If no name is supplied, YAME generates row IDs automatically. 3.2 Converting an existing .cr file to BED . yame unpack cpg_reference.cr &gt; cpg_ref.bed . This unpacking step is foundational for most workflows: . | Feature construction (Format 2) | BED-based intersection | Generating masks or windows | . ",
    "url": "/YAME/docs/formats/format7_reference.html#3-packing-to-format-7",
    
    "relUrl": "/docs/formats/format7_reference.html#3-packing-to-format-7"
  },"96": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "4. Using Format 7 as the Reference Genome for .cx Data",
    "content": "Every .cg / .cm file must: . | Contain one row per CpG | Follow the same ordering as the .cr file | Use the same genome build and coordinate convention | . To verify alignment: . yame info sample.cg . This prints: . | Row count | Format ID | Validity checks | Compatibility with .cr (if provided) | . 4.1 Aligning BED-like data to the reference CpGs . This is the standard workflow: . yame unpack cpg_reference.cr | gzip &gt; cpg_ref.bed.gz bedtools intersect -a cpg_ref.bed.gz -b input.bed -loj -sorted \\ | cut -f4 \\ | yame pack -fb - &gt; binary.cg . This ensures: . | Same ordering as .cr | One CpG per row | Missing positions explicitly included (value 0) | . 4.2 Aligning M/U counts or fraction values . See examples in Format 3 / Format 4 documentation: . bedtools intersect -a cpg_ref.bed.gz -b mu_counts.bed -loj -sorted \\ | awk '{print $8\"\\t\"$9}' \\ | yame pack -f3 - &gt; sample.cg . ",
    "url": "/YAME/docs/formats/format7_reference.html#4-using-format-7-as-the-reference-genome-for-cx-data",
    
    "relUrl": "/docs/formats/format7_reference.html#4-using-format-7-as-the-reference-genome-for-cx-data"
  },"97": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "5. Integration with YAME Commands",
    "content": ". 5.1 yame rowsub . Coordinate-based row selection requires .cr: . # Extract CpGs listed by genomic coordinate yame rowsub -R cpg_reference.cr -L CpG_sites.txt sample.cg &gt; subset.cg . 5.2 yame summary . Format 7 itself is not summarized, but masks and queries rely on the order defined by .cr. 5.3 yame chunk / yame chunkchar . When chunking .cg files: . yame chunk sample.cg chunks/ . the row boundaries respect .cr ordering. 5.4 Creating features (Format 2) requires .cr . Example: . yame unpack cpg_reference.cr | gzip &gt; cpg_ref.bed.gz bedtools intersect -a cpg_ref.bed.gz -b chromhmm.bed -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; ChromHMM.cm . ",
    "url": "/YAME/docs/formats/format7_reference.html#5-integration-with-yame-commands",
    
    "relUrl": "/docs/formats/format7_reference.html#5-integration-with-yame-commands"
  },"98": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "6. Choosing or Building a CpG Reference",
    "content": "Most users rely on prebuilt .cr files, e.g.: . | hg19: CpG_nocontig CR file | hg38: CpG_nocontig CR file | mm10, mm39: Available via KYCGKB repositories | . Custom genomes: . # Build your own CpG reference grep -E -o 'CG' -b genome.fa \\ | awk '{pos=$1; ... construct BED rows ... }' \\ &gt; cpg_coords.bed yame pack -f7 cpg_coords.bed &gt; cpg_reference.cr . ",
    "url": "/YAME/docs/formats/format7_reference.html#6-choosing-or-building-a-cpg-reference",
    
    "relUrl": "/docs/formats/format7_reference.html#6-choosing-or-building-a-cpg-reference"
  },"99": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "7. When NOT to Use Format 7",
    "content": "Do NOT use Format 7 for: . | Storing methylation data → use Formats 0,1,3,4,5,6 | Storing mask or feature annotations → use Format 2 | Storing per-sample or bulk CpG calls → use Formats 0/3/4 | . Format 7 is strictly a reference coordinate container. ",
    "url": "/YAME/docs/formats/format7_reference.html#7-when-not-to-use-format-7",
    
    "relUrl": "/docs/formats/format7_reference.html#7-when-not-to-use-format-7"
  },"100": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "8. Minimal End-to-End Example",
    "content": "# 1. Unpack the reference CpGs yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Align your BED data to reference CpGs bedtools intersect -a cpg_ref.bed.gz -b peaks.bed -loj -sorted \\ | cut -f4 \\ | yame pack -fb - &gt; peaks.cg # 3. Create a feature file using ChromHMM zcat ChromHMM.bed.gz \\ | bedtools intersect -a cpg_ref.bed.gz -b - -loj -sorted \\ | bedtools groupby -g 1-3 -c 7 -o first \\ | cut -f4 \\ | yame pack -f2 - &gt; chromhmm.cm # 4. Summarize enrichment yame summary -m chromhmm.cm peaks.cg &gt; enrich.txt . Format 7 is the foundation of all YAME workflows: It defines CpG identity, ordering, genomic position, and compatibility across all .cg and .cm files. A correct and consistent .cr file ensures that your entire methylation analysis pipeline remains coherent, efficient, and reproducible. ",
    "url": "/YAME/docs/formats/format7_reference.html#8-minimal-end-to-end-example",
    
    "relUrl": "/docs/formats/format7_reference.html#8-minimal-end-to-end-example"
  },"101": {
    "doc": "Fmt 7 – Ref Coordinates",
    "title": "Fmt 7 – Ref Coordinates",
    "content": " ",
    "url": "/YAME/docs/formats/format7_reference.html",
    
    "relUrl": "/docs/formats/format7_reference.html"
  },"102": {
    "doc": "Home",
    "title": "YAME - Yet Another Methylation Encoder",
    "content": "A fast and lightweight toolkit for sequence-level DNA methylation analysis . Get Started View on GitHub . ",
    "url": "/YAME/#yame---yet-another-methylation-encoder",
    
    "relUrl": "/#yame---yet-another-methylation-encoder"
  },"103": {
    "doc": "Home",
    "title": "Overview",
    "content": "YAME (Yet Another Methylation Encoder) is designed for efficient sequence-level DNA methylation data management, capable of handling both bulk and single-cell DNA methylome workflows. It introduces a family of compact binary formats (CX formats) that represent methylation values, MU counts, categorical states, fraction data, masks, and genomic coordinates in a uniform compressed structure. Use Cases include: . | Single-cell methylome analysis - Efficiently store and analyze sparse single-cell data | Bulk methylome processing - Fast operations on large cohorts | Enrichment testing - Test methylation enrichment across genomic features | Feature aggregation - Summarize methylation over bins, chromatin states, or custom regions | Pseudobulk generation - Merge single cells into cluster-level pseudobulks | Differential methylation - Identify and test differentially methylated sites | . ",
    "url": "/YAME/#overview",
    
    "relUrl": "/#overview"
  },"104": {
    "doc": "Home",
    "title": "Tutorials &amp; Workflows",
    "content": ". | Storage &amp; Format - Working with CX formats | Summarize &amp; Encode - Calculate statistics and aggregations | Test Enrichment - Test methylation enrichment across genomic features | Subset Rows - Extract samples and regions | Aggregate Row-wise - Merge pseudobulks and perform calculations | Combine, Split &amp; Index - Handle multi-sample datasets | Mask Data - Test methods at different sparsity levels | . ",
    "url": "/YAME/#tutorials--workflows",
    
    "relUrl": "/#tutorials--workflows"
  },"105": {
    "doc": "Home",
    "title": "Installation",
    "content": "# Option 1: Install via Conda (Recommended) conda install yame -c bioconda # Option 2: Build from Source git clone https://github.com/zhou-lab/YAME.git cd YAME make . ",
    "url": "/YAME/#installation",
    
    "relUrl": "/#installation"
  },"106": {
    "doc": "Home",
    "title": "Quick Start",
    "content": "# Pack binary methylation data yame pack -fb yourfile.bed &gt; yourfile.cg # Pack MU count data (M and U columns) yame pack -f3 methylation_counts.txt &gt; yourfile.cg # Summarize methylation data yame summary yourfile.cg # Test enrichment over genomic features yame summary -m ChromHMM_states.cm yourfile.cg &gt; enrichment_results.txt # Subset samples from multi-sample data yame subset -l sample_list.txt yourfile.cg &gt; subset.cg # Merge single cells into pseudobulks yame subset -l cluster1_cells.txt single_cell.cg | yame rowop - -o binasum &gt; pseudobulk.cg . ",
    "url": "/YAME/#quick-start",
    
    "relUrl": "/#quick-start"
  },"107": {
    "doc": "Home",
    "title": "Reference",
    "content": "Goldberg*, Fu*, Atkins, Moyer, Lee, Deng, Zhou† (2025) KnowYourCG: Facilitating Base-level Sparse Methylome Interpretation. Science Advances DOI: 10.1126/sciadv.adw3027 . ",
    "url": "/YAME/#reference",
    
    "relUrl": "/#reference"
  },"108": {
    "doc": "Home",
    "title": "Acknowledgements",
    "content": "This work is supported by NIH/NIGMS 5R35GM146978. YAME integrates with the KYCG knowledge base for comprehensive methylation feature analysis. ",
    "url": "/YAME/#acknowledgements",
    
    "relUrl": "/#acknowledgements"
  },"109": {
    "doc": "Home",
    "title": "Getting Help",
    "content": ". | Command Help: Run yame or yame &lt;command&gt; for usage information | Issues: Report bugs on GitHub Issues | KYCG Resources: Download reference coordinates and feature files from KYCG hg38 or KYCG mm10 | . ",
    "url": "/YAME/#getting-help",
    
    "relUrl": "/#getting-help"
  },"110": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/YAME/",
    
    "relUrl": "/"
  },"111": {
    "doc": "5. Aggregate Row-wise",
    "title": "5. Row-wise Aggregation of Methylation Sites",
    "content": "yame rowop provides fast, low-level operations applied row-by-row across all samples of a .cx file. These operations are frequently used in single-cell methylation analysis, pseudobulk aggregation, QC, and exploratory co-methylation analyses. Usage: yame rowop -o &lt;operation&gt; &lt;in.cx&gt; &lt;out&gt; . If &lt;out&gt; is omitted, results are written to stdout. ",
    "url": "/YAME/docs/rowop.html#5-row-wise-aggregation-of-methylation-sites",
    
    "relUrl": "/docs/rowop.html#5-row-wise-aggregation-of-methylation-sites"
  },"112": {
    "doc": "5. Aggregate Row-wise",
    "title": "5.1 Common Use Case: Summing Binary Data to Create Pseudobulks",
    "content": "A very common operation is to sum binarized methylation calls across cells belonging to the same cluster. For example, to generate a pseudobulk for cluster 1 from a single-cell .cg file: . yame subset -l cluster_1_id.txt single_cell.cg \\ | yame rowop -o binasum - &gt; cluster1_pseudobulk.cg . What binasum does: . | For binary formats (0/1): It counts how many cells have methylation = 1 vs 0. | For format 3 (M/U counts): It compares M vs U in each cell and votes for the majority state. Only rows with coverage ≥ -c mincov are counted. | . The output is a format 3 .cg file where each position contains: . | Total number of methylated votes (M) | Total number of unmethylated votes (U) | . This is ideal for downstream: . | Pseudobulk methylation beta estimates | Differential methylation analysis | Cluster-level QC | . ",
    "url": "/YAME/docs/rowop.html#51-common-use-case-summing-binary-data-to-create-pseudobulks",
    
    "relUrl": "/docs/rowop.html#51-common-use-case-summing-binary-data-to-create-pseudobulks"
  },"113": {
    "doc": "5. Aggregate Row-wise",
    "title": "5.2 Available Operations",
    "content": "Below is a complete list of operations supported by -o. ",
    "url": "/YAME/docs/rowop.html#52-available-operations",
    
    "relUrl": "/docs/rowop.html#52-available-operations"
  },"114": {
    "doc": "5. Aggregate Row-wise",
    "title": "1. binasum — Sum binarized methylation across samples",
    "content": "yame rowop -o binasum input.cx output.cx . | Works on formats 0, 1, and 3 | Produces a new format 3 dataset | For format 3 inputs, rows with depth &lt; -c (default 1) are ignored | Interprets each sample’s methylation as a binary vote | . Useful for: . | Pseudobulk construction | Collapsing replicates | Aggregating barcodes / technical partitions | . ",
    "url": "/YAME/docs/rowop.html#1-binasum--sum-binarized-methylation-across-samples",
    
    "relUrl": "/docs/rowop.html#1-binasum--sum-binarized-methylation-across-samples"
  },"115": {
    "doc": "5. Aggregate Row-wise",
    "title": "2. musum — Sum M and U counts directly",
    "content": "yame rowop -o musum input.cx output.cx . | Works only on format 3 | Directly adds up: . | all M counts | all U counts | . | Produces a new .cx file in format 3 | . Useful when: . | You want true aggregated read counts | You trust the original M/U values (not just binary interpretation) | . ",
    "url": "/YAME/docs/rowop.html#2-musum--sum-m-and-u-counts-directly",
    
    "relUrl": "/docs/rowop.html#2-musum--sum-m-and-u-counts-directly"
  },"116": {
    "doc": "5. Aggregate Row-wise",
    "title": "3. mean — Per-row methylation mean and count",
    "content": "yame rowop -o mean input.cx &gt; mean.tsv . Output (tab-delimited): . beta_mean number_of_valid_cells . Only samples with coverage ≥ -c contribute. Rows with no valid values output NA 0. Useful for: . | QC summaries | Computing single-cell methylation averages | Identifying globally variable CpGs | . ",
    "url": "/YAME/docs/rowop.html#3-mean--per-row-methylation-mean-and-count",
    
    "relUrl": "/docs/rowop.html#3-mean--per-row-methylation-mean-and-count"
  },"117": {
    "doc": "5. Aggregate Row-wise",
    "title": "4. std — Per-row methylation standard deviation",
    "content": "yame rowop -o std input.cx &gt; std.tsv . Output columns: . std_dev counts . Uses the same filtering as mean. Helpful for: . | Measuring variability | Ranking variable CpGs | Identifying DNA methylation landmarks | . ",
    "url": "/YAME/docs/rowop.html#4-std--per-row-methylation-standard-deviation",
    
    "relUrl": "/docs/rowop.html#4-std--per-row-methylation-standard-deviation"
  },"118": {
    "doc": "5. Aggregate Row-wise",
    "title": "5. binstring — Convert methylation profiles to binary strings",
    "content": "yame rowop -o binstring -b 0.6 input.cx &gt; binstrings.txt . | Converts each sample to a binary string per row | Threshold -b decides methylated vs unmethylated (default 0.5) | Outputs one string per row | . Example output: . 0010110101 1100001110 ... Useful for: . | Clustering by Hamming distance | Haplotype inference | Co-methylation motif discovery | Compression for machine learning models | . ",
    "url": "/YAME/docs/rowop.html#5-binstring--convert-methylation-profiles-to-binary-strings",
    
    "relUrl": "/docs/rowop.html#5-binstring--convert-methylation-profiles-to-binary-strings"
  },"119": {
    "doc": "5. Aggregate Row-wise",
    "title": "6. cometh — Co-methylation of neighboring CpGs",
    "content": "yame rowop -o cometh -w 5 input.cx &gt; cometh.tsv . For each CpG i and neighbors i+1 … i+w, cometh outputs a vector encoding four categories: . | U0U1 | U0M1 | M0U1 | M0M1 | . Counts are stored in a compact 64-bit representation; use -v to print them explicitly: . i U0U1-U0M1-M0U1-M0M1 U0U2-U0M2-M0U2-M0M2 ... Additional behavior: . | Only format 3 is allowed | Excludes intermediate methylation values (0.3–0.7) | Requires both CpGs to have depth ≥ -c mincov | -w sets window size (default: 5) | . This is useful for: . | Detecting locally coordinated methylation | Assessing haplotype methylation patterns | Fragment-level epiallele analysis | Identifying footprints or nucleosome-scale structure | . ",
    "url": "/YAME/docs/rowop.html#6-cometh--co-methylation-of-neighboring-cpgs",
    
    "relUrl": "/docs/rowop.html#6-cometh--co-methylation-of-neighboring-cpgs"
  },"120": {
    "doc": "5. Aggregate Row-wise",
    "title": "5.3 Summary of Operations",
    "content": "| Operation | Output Type | Input Requirement | Purpose | . | binasum | .cx (format 3) | fmt 0/1/3 | Pseudobulk / aggregation | . | musum | .cx (format 3) | fmt 3 | True count summation | . | mean | text | fmt 3 | Mean methylation per CpG | . | std | text | fmt 3 | Standard deviation per CpG | . | binstring | text | fmt 3 | Binary methylation strings | . | cometh | text | fmt 3 | Local co-methylation patterns | . ",
    "url": "/YAME/docs/rowop.html#53-summary-of-operations",
    
    "relUrl": "/docs/rowop.html#53-summary-of-operations"
  },"121": {
    "doc": "5. Aggregate Row-wise",
    "title": "5.4 Additional Notes",
    "content": "Minimum coverage control (-c) . Many operations ignore rows where: . M + U &lt; mincov . Default is 1. Verbose output (-v) . For cometh, verbose mode expands packed category counts into readable numbers. Binarization threshold (-b) . Relevant only for binstring. ",
    "url": "/YAME/docs/rowop.html#54-additional-notes",
    
    "relUrl": "/docs/rowop.html#54-additional-notes"
  },"122": {
    "doc": "5. Aggregate Row-wise",
    "title": "5.5 Help and Subcommand Documentation",
    "content": "For detailed usage: . yame rowop -h . Subcommand documentation: . | rowop help page | . ",
    "url": "/YAME/docs/rowop.html#55-help-and-subcommand-documentation",
    
    "relUrl": "/docs/rowop.html#55-help-and-subcommand-documentation"
  },"123": {
    "doc": "5. Aggregate Row-wise",
    "title": "5. Aggregate Row-wise",
    "content": " ",
    "url": "/YAME/docs/rowop.html",
    
    "relUrl": "/docs/rowop.html"
  },"124": {
    "doc": "4. Subset Rows",
    "title": "4. Subsetting Rows in a Packed .cx File",
    "content": "YAME provides several tools for extracting subsets of rows (genomic sites) or breaking a .cx file into smaller pieces. The main tools covered here are: . | yame rowsub — extract specific CpG rows or ranges | yame chunk — divide a .cx file into size-based chunks | yame chunkchar — divide large text files into size-based chunks | . This section describes how to use each tool and the most common workflows. ",
    "url": "/YAME/docs/rowsub.html#4-subsetting-rows-in-a-packed-cx-file",
    
    "relUrl": "/docs/rowsub.html#4-subsetting-rows-in-a-packed-cx-file"
  },"125": {
    "doc": "4. Subset Rows",
    "title": "4.1 Subset CpG Rows with yame rowsub",
    "content": "yame rowsub allows you to extract specific genomic rows from a .cx file. This is useful when: . | You want methylation values only at specific CpG sites | You want to subset a contiguous genomic block | You want to filter using a binary mask (fmt0) | You want to extract rows by genomic coordinate rather than integer index | . The output is written to stdout, allowing direct piping or saving to file. ",
    "url": "/YAME/docs/rowsub.html#41-subset-cpg-rows-with-yame-rowsub",
    
    "relUrl": "/docs/rowsub.html#41-subset-cpg-rows-with-yame-rowsub"
  },"126": {
    "doc": "4. Subset Rows",
    "title": "Basic Usage",
    "content": "yame rowsub [options] &lt;in.cx&gt; &gt; subset.cx . The command supports three major ways to select rows: . ",
    "url": "/YAME/docs/rowsub.html#basic-usage",
    
    "relUrl": "/docs/rowsub.html#basic-usage"
  },"127": {
    "doc": "4. Subset Rows",
    "title": "A. Select rows by integer index (-l)",
    "content": "If you have a list of row indices (1-based), e.g.: . 12 455 9012 ... Then run: . yame rowsub -l row_ids.txt yourfile.cx &gt; subset.cx . No sorting is required; YAME internally maintains the given order. ",
    "url": "/YAME/docs/rowsub.html#a-select-rows-by-integer-index--l",
    
    "relUrl": "/docs/rowsub.html#a-select-rows-by-integer-index--l"
  },"128": {
    "doc": "4. Subset Rows",
    "title": "B. Select rows by genomic coordinate labels (-L + -R)",
    "content": "This is the most common method for extracting specific CpG sites. You will need: . | A row coordinate file (.cr) containing genome coordinates for each .cx row YAME provides: . | mm10 row coordinates | hg38 row coordinates | . | A list of site names in the format chr_beg1, one per line, e.g.: . | . chr16_18300002 chr16_18300046 chr16_18300140 chr16_18300162 chr16_18300172 . Then run: . yame rowsub -R cpg_nocontig.cr -L CpG_sites.tsv yourfile.cx &gt; subset.cx . YAME internally: . | Loads the .cr coordinate file | Maps each chrX_pos string to the correct row index | Extracts only those rows | Outputs a smaller .cx | . You can also include coordinates as the first dataset in the output with: . yame rowsub -1 -R cpg_nocontig.cr -L CpG_sites.tsv yourfile.cx &gt; subset.cx . ",
    "url": "/YAME/docs/rowsub.html#b-select-rows-by-genomic-coordinate-labels--l---r",
    
    "relUrl": "/docs/rowsub.html#b-select-rows-by-genomic-coordinate-labels--l---r"
  },"129": {
    "doc": "4. Subset Rows",
    "title": "C. Select rows using a binary mask (-m)",
    "content": "Mask file must be format 0 or 1, representing a vector of 0/1 flags. Example: . yame rowsub -m mask.cx yourfile.cx &gt; subset.cx . Any row where the mask equals 1 is retained. This acts similarly to feature masking in yame summary. ",
    "url": "/YAME/docs/rowsub.html#c-select-rows-using-a-binary-mask--m",
    
    "relUrl": "/docs/rowsub.html#c-select-rows-using-a-binary-mask--m"
  },"130": {
    "doc": "4. Subset Rows",
    "title": "D. Select a contiguous block (-B or -I)",
    "content": "Select a row range (0-based): . yame rowsub -B 1000_2000 yourfile.cx &gt; subset.cx . Extracts rows 1000–1999. If only one number is given: . yame rowsub -B 1000 yourfile.cx . Outputs a single row. Select a block by block index (-I) . Useful for chunked batch processing: . yame rowsub -I 5_1000000 yourfile.cx . This extracts: . | Block index = 5 | Block size = 1,000,000 rows | Row range = 5,000,000 to 5,999,999 | . If block size is omitted, default = 1,000,000. ",
    "url": "/YAME/docs/rowsub.html#d-select-a-contiguous-block--b-or--i",
    
    "relUrl": "/docs/rowsub.html#d-select-a-contiguous-block--b-or--i"
  },"131": {
    "doc": "4. Subset Rows",
    "title": "Summary: Ways to Select Rows",
    "content": "| Method | Option | When to Use | . | Integer row list | -l &lt;file&gt; | You know row indices | . | Genomic coords | -L &lt;file&gt; -R &lt;row.cr&gt; | You know genome coordinates | . | Binary mask | -m &lt;mask.cx&gt; | Filtering by precomputed selection | . | Range of rows | -B &lt;beg_end&gt; | Simple slicing by index | . | Block slicing | -I &lt;block_blockSize&gt; | Batch processing | . | Include coords in output | -1 | To append .cr for clarity | . ",
    "url": "/YAME/docs/rowsub.html#summary-ways-to-select-rows",
    
    "relUrl": "/docs/rowsub.html#summary-ways-to-select-rows"
  },"132": {
    "doc": "4. Subset Rows",
    "title": "4.1.1 rowsub Common Examples",
    "content": "Extract a single genomic region . yame rowsub -B 500000_510000 input.cx &gt; region.cx . Extract CpGs in a BED region . (using row coordinate file + interval expansion) . awk '{print $1\"_\"$2+1}' region.bed &gt; coords.txt yame rowsub -R genome.cr -L coords.txt input.cx &gt; subset.cx . Apply a mask file . yame rowsub -m mymask.cx input.cx &gt; masked.cx . ",
    "url": "/YAME/docs/rowsub.html#411-rowsub-common-examples",
    
    "relUrl": "/docs/rowsub.html#411-rowsub-common-examples"
  },"133": {
    "doc": "4. Subset Rows",
    "title": "4.2 Chunking .cx Files with yame chunk",
    "content": "yame chunk splits a packed .cx file into multiple smaller .cx files, each containing a fixed number of rows. This is essential for: . | Distributed computing | Parallel model training | Memory-efficient processing | Splitting extremely large .cx files into manageable pieces | . ",
    "url": "/YAME/docs/rowsub.html#42-chunking-cx-files-with-yame-chunk",
    
    "relUrl": "/docs/rowsub.html#42-chunking-cx-files-with-yame-chunk"
  },"134": {
    "doc": "4. Subset Rows",
    "title": "Basic Usage",
    "content": "yame chunk -s &lt;chunkSize&gt; input.cx output_dir/ . If output_dir is not provided, a directory named: . input.cx_chunks/ . is automatically created. ",
    "url": "/YAME/docs/rowsub.html#basic-usage-1",
    
    "relUrl": "/docs/rowsub.html#basic-usage-1"
  },"135": {
    "doc": "4. Subset Rows",
    "title": "Example",
    "content": "Split into chunks of 500,000 rows each: . yame chunk -s 500000 input.cx chunks/ . This produces: . chunks/0.cx chunks/1.cx chunks/2.cx ... Each chunk file maintains the same number of samples as the original. All samples are split identically row-wise. ",
    "url": "/YAME/docs/rowsub.html#example",
    
    "relUrl": "/docs/rowsub.html#example"
  },"136": {
    "doc": "4. Subset Rows",
    "title": "4.3 Chunking Text Files with yame chunkchar",
    "content": "yame chunkchar works like chunk, but for plain text files rather than .cx files. This is useful for splitting: . | BED files | FASTA headers | List files | Any long line-based text file | . ",
    "url": "/YAME/docs/rowsub.html#43-chunking-text-files-with-yame-chunkchar",
    
    "relUrl": "/docs/rowsub.html#43-chunking-text-files-with-yame-chunkchar"
  },"137": {
    "doc": "4. Subset Rows",
    "title": "Basic Usage",
    "content": "yame chunkchar -s &lt;chunkSize&gt; input.txt . By default, output is written to: . input.txt_chunks/ . ",
    "url": "/YAME/docs/rowsub.html#basic-usage-2",
    
    "relUrl": "/docs/rowsub.html#basic-usage-2"
  },"138": {
    "doc": "4. Subset Rows",
    "title": "Example",
    "content": "Split a large text file into 1M-line chunks: . yame chunkchar -s 1000000 sites.txt . Outputs: . sites.txt_chunks/0.txt sites.txt_chunks/1.txt sites.txt_chunks/2.txt ... Each file contains up to chunkSize lines. ",
    "url": "/YAME/docs/rowsub.html#example-1",
    
    "relUrl": "/docs/rowsub.html#example-1"
  },"139": {
    "doc": "4. Subset Rows",
    "title": "4.4 Help and Developer References",
    "content": "For additional details: . | Run with -h . yame rowsub -h yame chunk -h yame chunkchar -h . | See full subcommand documentation: . | rowsub help page | chunk help page | chunkchar help page | . | . ",
    "url": "/YAME/docs/rowsub.html#44-help-and-developer-references",
    
    "relUrl": "/docs/rowsub.html#44-help-and-developer-references"
  },"140": {
    "doc": "4. Subset Rows",
    "title": "4.5 Summary Table",
    "content": "| Command | Input | Output | Purpose | . | rowsub | .cx | .cx to stdout | Fine-grained row selection | . | chunk | .cx | multiple .cx | Split methylation matrix into fixed-size parts | . | chunkchar | text | multiple .txt | Split large text files | . ",
    "url": "/YAME/docs/rowsub.html#45-summary-table",
    
    "relUrl": "/docs/rowsub.html#45-summary-table"
  },"141": {
    "doc": "4. Subset Rows",
    "title": "4. Subset Rows",
    "content": " ",
    "url": "/YAME/docs/rowsub.html",
    
    "relUrl": "/docs/rowsub.html"
  },"142": {
    "doc": "6. Combine, Split & Index",
    "title": "6. Combine, Split &amp; Index",
    "content": "This section covers operations that manipulate samples (columns) in a .cx file: . | yame index — build or update a sample index | yame split — split a multi-sample .cx file into individual .cx files | yame subset — extract selected samples or states | Combining files — achieved using standard Unix cat | . These tools are essential for workflows that involve multiple .cx samples, such as merging epigenomic features, analyzing groups of samples, or reorganizing sample structure. ",
    "url": "/YAME/docs/sample.html#6-combine-split--index",
    
    "relUrl": "/docs/sample.html#6-combine-split--index"
  },"143": {
    "doc": "6. Combine, Split & Index",
    "title": "6.1 Generating and Updating Index Files (yame index)",
    "content": "A .cx file containing multiple samples stores its samples sequentially, and YAME uses an accompanying index file (.cx.idx) to record the byte offset of each sample. You can generate an index using: . yame index yourfile.cx . This produces: . yourfile.cx.idx . with two columns: . sample_name byte_offset . ",
    "url": "/YAME/docs/sample.html#61-generating-and-updating-index-files-yame-index",
    
    "relUrl": "/docs/sample.html#61-generating-and-updating-index-files-yame-index"
  },"144": {
    "doc": "6. Combine, Split & Index",
    "title": "Assigning Sample Names from a List",
    "content": "If the .cx has N samples but no index file, provide a sample-name list: . yame index -s sample_names.tsv yourfile.cx . sample_names.tsv contains names in its first column. ",
    "url": "/YAME/docs/sample.html#assigning-sample-names-from-a-list",
    
    "relUrl": "/docs/sample.html#assigning-sample-names-from-a-list"
  },"145": {
    "doc": "6. Combine, Split & Index",
    "title": "Appending a New Sample (-1)",
    "content": "If you have added an extra cdata block to the end of a .cx file, you may append it to the existing index: . yame index -1 NewSampleName yourfile.cx . YAME locates the final block and records the offset of the newly appended sample. ",
    "url": "/YAME/docs/sample.html#appending-a-new-sample--1",
    
    "relUrl": "/docs/sample.html#appending-a-new-sample--1"
  },"146": {
    "doc": "6. Combine, Split & Index",
    "title": "Output to Console",
    "content": "yame index -c yourfile.cx . This prints the index to stdout instead of writing yourfile.cx.idx. ",
    "url": "/YAME/docs/sample.html#output-to-console",
    
    "relUrl": "/docs/sample.html#output-to-console"
  },"147": {
    "doc": "6. Combine, Split & Index",
    "title": "6.2 Example: Merging Multiple .cm Feature Files",
    "content": "This example demonstrates how to: . | Convert many BED files into .cm feature files | QC them | Merge them together | Generate a combined index | . Step 1 — Prepare the table describing sample IDs and BED paths . 268 GSM648494 human_hm/268_sort_peaks.narrowPeak.bed 269 GSM648495 human_hm/269_sort_peaks.narrowPeak.bed 272 GSM575295 human_hm/272_b_sort_peaks.broadPeak.bed ... Step 2 — Convert each BED into .cm . cat controlfiles.tsv \\ | parallel --colsep '\\t' -j 72 ' id={1}; path={3}; sortbed $path \\ | bedtools intersect -a cpg_nocontig.bed.gz -b - -sorted -c \\ | cut -f4 \\ | yame pack -f b - $id.cm ' . Each $id.cm is a binary feature mask aligned to the CpG coordinate list. Step 3 — QC each .cm . awk '{print \"\"$1\".cm\", $2\";\"$4;}' controlfiles.tsv \\ | while read fn anno; do yame summary $fn; done \\ &gt; qc.txt . Example filter: keep feature files with ≥ 5000 overlapping CpGs. Step 4 — Merge and index . awk '$1!~/QFile/ &amp;&amp; $6&gt;5000' qc.txt \\ | awk 'NR==FNR{a[$1]=1;}NR!=FNR&amp;&amp;($1\".cm\" in a){print $0;}' - controlfiles.tsv \\ | awk '{print \"\"$1\".cm\", $2\";\"$4;}' \\ | sort -k2,2 \\ | while read fn anno; do cat $fn &gt;&gt; merged.cm yame index -1 $anno merged.cm done . merged.cm is the concatenation of all retained .cm samples, with indexing updated each iteration. ",
    "url": "/YAME/docs/sample.html#62-example-merging-multiple-cm-feature-files",
    
    "relUrl": "/docs/sample.html#62-example-merging-multiple-cm-feature-files"
  },"148": {
    "doc": "6. Combine, Split & Index",
    "title": "6.3 Splitting Multi-Sample Files (yame split)",
    "content": "yame split takes a multi-sample .cx file and produces one .cx file per sample. Basic usage: . yame split input.cx output_prefix . If sample names are present in the index, the output naming scheme becomes: . output_prefix&lt;SampleName&gt;.cx . Otherwise: . output_prefix_split_1.cx output_prefix_split_2.cx ... ",
    "url": "/YAME/docs/sample.html#63-splitting-multi-sample-files-yame-split",
    
    "relUrl": "/docs/sample.html#63-splitting-multi-sample-files-yame-split"
  },"149": {
    "doc": "6. Combine, Split & Index",
    "title": "Providing a Sample List",
    "content": "If the .cx has no index file but you know sample names: . yame split -s sample_list.txt input.cx prefix_ . sample_list.txt should contain one name per line. This preserves sample naming and ensures the prefix_&lt;sample&gt;.cx files correspond correctly. For more help: . | split help page | . ",
    "url": "/YAME/docs/sample.html#providing-a-sample-list",
    
    "relUrl": "/docs/sample.html#providing-a-sample-list"
  },"150": {
    "doc": "6. Combine, Split & Index",
    "title": "6.4 Subsetting Samples (yame subset)",
    "content": "yame subset extracts a subset of samples from a multi-sample .cx file. It uses the .cx.idx file to locate and extract the requested samples efficiently. Basic syntax: . yame subset -l sample_list.txt input.cx &gt; subset.cx . or: . yame subset input.cx SampleA SampleB SampleC &gt; subset.cx . If you specify an output file via -o, YAME writes both: . | the new subset .cx | a new index .cx.idx | . Example: . yame subset -o cluster1.cx singlecell.cx Cell_01 Cell_07 Cell_33 . Head / Tail extraction . Useful for inspecting the first or last N samples: . yame subset -H 10 input.cx &gt; first10.cx # first 10 samples yame subset -T 5 input.cx &gt; last5.cx # last 5 samples . Subsetting Format 2 states (-s) . If the input is a format 2 .cx file (categorical states), you may split states into binary masks: . yame subset -s -l state_list.txt -o states.cx chromatin_states.cx . This produces one binary vector per selected state. For more help: . | subset help page | . ",
    "url": "/YAME/docs/sample.html#64-subsetting-samples-yame-subset",
    
    "relUrl": "/docs/sample.html#64-subsetting-samples-yame-subset"
  },"151": {
    "doc": "6. Combine, Split & Index",
    "title": "6.5 Combining .cx Files",
    "content": "YAME does not provide a dedicated combine command because combining .cx files is equivalent to concatenation: . cat sample1.cx sample2.cx sample3.cx &gt; combined.cx yame index combined.cx . Rules: . | All .cx files must have the same format and same row dimension. | After combining, run yame index to regenerate the sample index. | . This pattern is used in the .cm merging example above. ",
    "url": "/YAME/docs/sample.html#65-combining-cx-files",
    
    "relUrl": "/docs/sample.html#65-combining-cx-files"
  },"152": {
    "doc": "6. Combine, Split & Index",
    "title": "Summary of Commands",
    "content": "| Command | Purpose | Notes | . | yame index | Build or update a .cx.idx sample index | Required for fast sample lookup | . | yame split | Produce one .cx per sample | Naming uses index or user-supplied list | . | yame subset | Extract selected samples or states | Supports head/tail and format-2 filtering | . | cat | Combine .cx files | Must re-index after concatenation | . ",
    "url": "/YAME/docs/sample.html#summary-of-commands",
    
    "relUrl": "/docs/sample.html#summary-of-commands"
  },"153": {
    "doc": "6. Combine, Split & Index",
    "title": "6. Combine, Split & Index",
    "content": " ",
    "url": "/YAME/docs/sample.html",
    
    "relUrl": "/docs/sample.html"
  },"154": {
    "doc": "1. Storage & Format",
    "title": "1. Storage &amp; Format",
    "content": "Convert between text and compressed CX binary formats for efficient storage and analysis. ",
    "url": "/YAME/docs/storage.html#1-storage--format",
    
    "relUrl": "/docs/storage.html#1-storage--format"
  },"155": {
    "doc": "1. Storage & Format",
    "title": "Overview",
    "content": "YAME’s pack and unpack commands provide bidirectional conversion between human-readable text formats (BED/TSV/etc.) and the compressed CX binary formats. CX formats: . | Dramatically reduce storage requirements (often 10–100×) | Are optimized for different methylation / feature data types | Are interoperable across all YAME commands | . Most workflows follow this pattern: . | Align your data to a CpG reference coordinate file (.cr, format 7) | Pack into an appropriate CX format (0/2/3/4/5/6) | Use other YAME commands (summary, rowsub, rowop, subset, etc.) | Optionally unpack to text for external tools | . ",
    "url": "/YAME/docs/storage.html#overview",
    
    "relUrl": "/docs/storage.html#overview"
  },"156": {
    "doc": "1. Storage & Format",
    "title": "Format Overview",
    "content": "YAME currently supports the following CX format family: . | Format | Code | Typical Ext | Best for | . | Format 0 | 0 / b | .cg | Binary presence/absence (DMR sites, ChIP-seq peaks, generic 0/1 tracks) | . | Format 1 | 1 | .cg | Integer values with RLE (count tracks, QC metrics, per-CpG integer signals) | . | Format 2 | 2 / s | .cm | Chromatin states, genomic annotations, gene features, windows/bins | . | Format 3 | 3 / m | .cg | M/U read counts from bisulfite sequencing | . | Format 4 | 4 | .cg | Continuous methylation values (beta/fraction), array/WGBS imputed values | . | Format 5 | 5 | .cg | Ternary differential calls (hypo / unchanged / hyper) | . | Format 6 | 6 | .cg | Query + universe representation for enrichment; sparse single-cell methylation | . | Format 7 | 7 | .cr | CpG genomic reference coordinates (required for all .cg / .cm files) | . All CX formats use BGZF compression and share a consistent internal structure (cdata_t blocks), enabling uniform handling across different data types. ",
    "url": "/YAME/docs/storage.html#format-overview",
    
    "relUrl": "/docs/storage.html#format-overview"
  },"157": {
    "doc": "1. Storage & Format",
    "title": "Pack / Unpack Basics",
    "content": "The core commands are: . # Pack text → CX yame pack -f&lt;format&gt; [options] &lt;input.txt&gt; [output.cx] # Read from stdin: cat data.txt | yame pack -fb - data.cg # Unpack CX → text yame unpack [options] &lt;input.cx&gt; . ⚠️ Your input MUST match reference CpG coordinates exactly: . | Same number of rows as reference CpGs | Same order as reference CpGs | One value per CpG in reference | . How to ensure alignment: . # Step 1: Get reference coordinates yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # Step 2: Intersect your BED file with reference bedtools intersect -a cpg_ref.bed.gz -b your_data.bed -sorted -c | \\ cut -f4 | \\ yame pack -fb - &gt; aligned_output.cg # the following two output should match in dimension yame info cpg_nocontig.cr yame info aligned_output.cg . A more complete workflow (including reference coordinate alignment) is described in each format’s page. ",
    "url": "/YAME/docs/storage.html#pack--unpack-basics",
    
    "relUrl": "/docs/storage.html#pack--unpack-basics"
  },"158": {
    "doc": "1. Storage & Format",
    "title": "Practical Workflows",
    "content": "Workflow 1: Process Bisulfite Sequencing Data . Complete pipeline from bisulfite sequencing output to analysis: . # Assuming you have M and U counts from your pipeline # Format: chr start end M U # 1. Extract M and U, align with reference bedtools intersect -a cpg_ref.bed.gz -b methylation_calls.bed -loj -sorted | \\ awk '{if ($8==\".\") print \"0\\t0\"; else print $8\"\\t\"$9}' | \\ yame pack -f3 - &gt; sample.cg # 2. Verify data quality yame info sample.cg yame summary sample.cg # 3. Perform enrichment analysis yame summary -m ChromHMM.cm sample.cg &gt; chromatin_enrichment.txt yame summary -m genes.cm sample.cg &gt; gene_enrichment.txt # 4. If needed, unpack for external tools yame unpack -f 5 sample.cg &gt; sample_cov5.txt . Workflow 2: Create Multi-Feature Database . Build comprehensive feature database: . #!/bin/bash # Create comprehensive feature database for hg38 # 1. Prepare reference yame unpack cpg_nocontig.cr | gzip &gt; cpg_ref.bed.gz # 2. Download and process multiple features declare -A features=( [\"ChromHMM_15\"]=\"ChromHMM_15state.bed.gz\" [\"CpG_Islands\"]=\"cpgIslandExt.bed.gz\" [\"Promoters\"]=\"promoters_2kb.bed.gz\" [\"Enhancers\"]=\"enhancers_merged.bed.gz\" [\"TFBS\"]=\"tfbs_combined.bed.gz\" ) # 3. Create individual feature files for name in \"${!features[@]}\"; do file=\"${features[$name]}\" echo \"Processing $name...\" zcat \"$file\" | bedtools sort | \\ bedtools intersect -a cpg_ref.bed.gz -b - -loj -sorted | \\ bedtools groupby -g 1-3 -c 7 -o first | \\ cut -f4 | \\ yame pack -f2 - &gt; \"${name}.cm\" done echo \"Feature files created:\" ls -lh *.cm . Workflow 3: Convert Array Data to CX Format . Convert Illumina array data: . #!/bin/bash # Convert 450k/EPIC array data to CX format # Assuming you have: array_data.txt with columns: ProbeID, Beta # 1. Get array manifest with probe coordinates # manifest.bed format: chr start end ProbeID # 2. Intersect with reference CpGs bedtools intersect -a cpg_ref.bed.gz -b manifest.bed -loj -sorted &gt; probe_cpg_map.bed # 3. Map betas to CpG positions join -1 4 -2 1 -t$'\\t' \\ &lt;(sort -k4,4 probe_cpg_map.bed) \\ &lt;(sort -k1,1 array_data.txt) | \\ sort -k2,2 -k3,3n | \\ cut -f7 | \\ awk '{if ($1==\"\") print \"NA\"; else print $1}' | \\ yame pack -f4 - &gt; array_sample.cg echo \"Array data converted to CX format\" yame info array_sample.cg . ",
    "url": "/YAME/docs/storage.html#practical-workflows",
    
    "relUrl": "/docs/storage.html#practical-workflows"
  },"159": {
    "doc": "1. Storage & Format",
    "title": "Best Practices",
    "content": ". | Always align with reference first bedtools intersect -a cpg_ref.bed.gz -b your_data.bed -sorted -c . | Verify dimensions match # Count reference CpGs zcat cpg_ref.bed.gz | wc -l # Count your data rows wc -l your_data.txt . | Handle missing values properly . | Format 3: Use M=0, U=0 for no coverage | Format 4: Use “NA” for missing values | Format 2: Use “.” for unassigned CpGs | . | . ",
    "url": "/YAME/docs/storage.html#best-practices",
    
    "relUrl": "/docs/storage.html#best-practices"
  },"160": {
    "doc": "1. Storage & Format",
    "title": "1. Storage & Format",
    "content": " ",
    "url": "/YAME/docs/storage.html",
    
    "relUrl": "/docs/storage.html"
  },"161": {
    "doc": "YAME Subcommands",
    "title": "YAME Subcommands",
    "content": "Usage for all YAME subcommands (printed with YAME). Program: yame (Yet Another Methylation tool) - whole genome DNA methylation data management. Version: 0.3.20230904 Contact: Wanding Zhou&lt;wanding.zhou@pennmedicine.upenn.edu&gt; Usage: yame &lt;command&gt; [options] Available commands: pack - Pack data into a cx file. unpack - Unpack data from a cx file. subset - Subset samples from a cx file. rowsub - Subset rows a cx file using an index list file. info - Display basic parameter of the cx file. summary - calculate summary, with or without masks. index - Index samples in a cx file. split - Split multi-sample data into single-sample data. chunk - Chunk data into smaller fragments. chunkchar - Chunk text data into smaller fragments. rowop - Perform operations on rows, e.g., sum binary values. mask - Mask methylation data by setting masked record to M=U=0. dsample - Downsample methylation data by setting unsampled records to M=U=0. ",
    "url": "/YAME/docs/subcommands",
    
    "relUrl": "/docs/subcommands"
  },"162": {
    "doc": "2. Summarize & Encode",
    "title": "2. Summarization of Packed .cx Files",
    "content": "yame summary and yame info provide quick, high-level summaries of .cx files created via yame pack. These tools help users inspect sample names, structural parameters, and feature-level statistics such as enrichment, methylation levels, and coverage. To run a simple summary: . yame info yourfile.cg yame summary yourfile.cg . Both single-sample and multi-sample .cx files are supported. ",
    "url": "/YAME/docs/summarize.html#2-summarization-of-packed-cx-files",
    
    "relUrl": "/docs/summarize.html#2-summarization-of-packed-cx-files"
  },"163": {
    "doc": "2. Summarize & Encode",
    "title": "Overview of What yame summary Computes",
    "content": "For each query sample, YAME reports: . | N_univ — total number of sites considered (universe) | N_query — number of sites present or methylated in the query | N_mask — number of sites in the mask | N_overlap — intersection of query and mask | Log2OddsRatio — an enrichment score | Beta — average methylation or proportion (format dependent) | Depth — approximate sequencing depth (only for formats with M/U counts) | . Mask files may contain multiple masks; each is evaluated independently. ",
    "url": "/YAME/docs/summarize.html#overview-of-what-yame-summary-computes",
    
    "relUrl": "/docs/summarize.html#overview-of-what-yame-summary-computes"
  },"164": {
    "doc": "2. Summarize & Encode",
    "title": "Supported Input Formats",
    "content": "The query .cx file may be in any of the following internal YAME formats: . | Format | Meaning | How Summary Interprets It | . | 0 / 1 | Binary vectors | Presence/absence | . | 2 | State labels | Multi-class state-specific summary | . | 3 | Methylation (M/U counts) | Beta, depth, overlap | . | 6 | Binary with universe bit | Sparse methylation (e.g., single cell) | . Masks (-m) may also be in formats 0, 1, 2, or 6. Format 7 (BED-like coordinates) is ignored by summary. ",
    "url": "/YAME/docs/summarize.html#supported-input-formats",
    
    "relUrl": "/docs/summarize.html#supported-input-formats"
  },"165": {
    "doc": "2. Summarize & Encode",
    "title": "Using Mask Feature Files",
    "content": "Masks allow aggregation of methylation or presence across functional features, e.g.: . | Fixed-size windows | Chromatin states | CpG islands, gene promoters | Custom regions | . Each mask is processed as a separate feature, producing a separate row in the summary output. If no mask is provided, YAME produces a global summary of the entire dataset. ",
    "url": "/YAME/docs/summarize.html#using-mask-feature-files",
    
    "relUrl": "/docs/summarize.html#using-mask-feature-files"
  },"166": {
    "doc": "2. Summarize & Encode",
    "title": "Example: Summarization with a Window Mask File",
    "content": "Single-cell DNA methylomes are sparse, so window bins (e.g., 100 kb) are commonly used. Download the mask file: . wget https://raw.githubusercontent.com/zhou-lab/KYCGKB_mm10/main/Win100k.20220228.cm . Run: . yame summary -m Win100k.20220228.cm single_cell.cg . Example output: . QFile Query MFile Mask N_univ N_query N_mask N_overlap Log2OddsRatio Beta Depth single_cell.cg Sample1 Win100k.20220228.cm chr1:30 21867837 1861715 589 48 -0.07 0.688 0.1 single_cell.cg Sample1 Win100k.20220228.cm chr1:31 21867837 1861715 574 36 -0.48 0.917 0.1 . ",
    "url": "/YAME/docs/summarize.html#example-summarization-with-a-window-mask-file",
    
    "relUrl": "/docs/summarize.html#example-summarization-with-a-window-mask-file"
  },"167": {
    "doc": "2. Summarize & Encode",
    "title": "Explanation of Output Columns",
    "content": "1. QFile . The query .cx file. 2. Query . Sample name from the sample index. If missing, YAME assigns numerical IDs. 3. MFile . The mask file used (or \"global\" when no mask is provided). 4. Mask . The name of each mask: . | State label for format 2 | Sample name for binary masks | Key names if -T is used | . 5. N_univ . Number of valid universe sites, depending on format: . | Format 6 uses only universe-bit sites | Other formats use total vector length | . 6. N_query . Number of “present” positions in the query: . | Formats 0/1: value = 1 | Format 3: sites with nonzero M+U | Format 6: universe-bit and set-bit sites | . 7. N_mask . Number of positions included in the mask. 8. N_overlap . Intersection of query and mask. 9. Log2OddsRatio . Enrichment score computed from the 2×2 contingency table of query × mask membership. 10. Beta . Average methylation or binary fraction inside the mask: . | Format 3: mean M/(M+U) | Binary formats: fraction of “1” | Format 6: fraction of SET sites within universe | . 11. Depth . Average sequencing depth (M+U) across mask sites (format 3 only). ",
    "url": "/YAME/docs/summarize.html#explanation-of-output-columns",
    
    "relUrl": "/docs/summarize.html#explanation-of-output-columns"
  },"168": {
    "doc": "2. Summarize & Encode",
    "title": "Special Behaviors",
    "content": "Multiple Masks . If the mask file contains multiple samples, each is processed independently. State Masks (Format 2) . Each state produces a distinct summary row. Universe Subsetting (-u) . Applies an additional universe mask to both query and features. Memory Mode (-M) . Loads all masks into RAM to minimize disk access. Header Suppression (-H) . Removes the header line for scripting convenience. ",
    "url": "/YAME/docs/summarize.html#special-behaviors",
    
    "relUrl": "/docs/summarize.html#special-behaviors"
  },"169": {
    "doc": "2. Summarize & Encode",
    "title": "Command Reference",
    "content": "Usage: yame summary [options] &lt;query.cx&gt; Options: -m FILE Mask feature (.cx) file. May contain multiple masks. -M Load all masks into memory. -u FILE Optional universe .cx file. -H Suppress header output. -q NAME Name to use when query file is '-'. -F Use full file paths in output. -T Always show section names (format 2). -s FILE Sample list overriding the query index. -h Display help. ",
    "url": "/YAME/docs/summarize.html#command-reference",
    
    "relUrl": "/docs/summarize.html#command-reference"
  },"170": {
    "doc": "2. Summarize & Encode",
    "title": "Additional Documentation",
    "content": "See also: . | Feature enrichment guide | Subcommand documentation | . ",
    "url": "/YAME/docs/summarize.html#additional-documentation",
    
    "relUrl": "/docs/summarize.html#additional-documentation"
  },"171": {
    "doc": "2. Summarize & Encode",
    "title": "2. Summarize & Encode",
    "content": " ",
    "url": "/YAME/docs/summarize.html",
    
    "relUrl": "/docs/summarize.html"
  }
}
